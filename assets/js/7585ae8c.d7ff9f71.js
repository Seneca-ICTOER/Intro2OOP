"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[123],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,h=m["".concat(o,".").concat(u)]||m[u]||d[u]||l;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,s=new Array(l);s[0]=u;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r[m]="string"==typeof e?e:i,s[1]=r;for(var p=2;p<l;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8365:function(e,t,n){n.r(t),n.d(t,{assets:function(){return o},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return r},toc:function(){return p}});var a=n(3117),i=(n(7294),n(3905));const l={id:"templates",title:"Templates",sidebar_position:3,description:"TBD"},s="Templates",r={unversionedId:"E-Polymorphism/templates",id:"E-Polymorphism/templates",title:"Templates",description:"TBD",source:"@site/docs/E-Polymorphism/templates.md",sourceDirName:"E-Polymorphism",slug:"/E-Polymorphism/templates",permalink:"/E-Polymorphism/templates",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/E-Polymorphism/templates.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"templates",title:"Templates",sidebar_position:3,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Abstract Base Classes",permalink:"/E-Polymorphism/abstract-base-classes"},next:{title:"Overview of Polymorphism",permalink:"/E-Polymorphism/overview-of-polymorphism"}},o={},p=[{value:"Function Template",id:"function-template",level:2},{value:"Template Syntax",id:"template-syntax",level:3},{value:"Complete Definition",id:"complete-definition",level:3},{value:"Calling a Templated Function",id:"calling-a-templated-function",level:3},{value:"Class Template",id:"class-template",level:2},{value:"Constrained Casts",id:"constrained-casts",level:2},{value:"Related Types",id:"related-types",level:3},{value:"Unrelated Types",id:"unrelated-types",level:3},{value:"Unmodifiable Types",id:"unmodifiable-types",level:3},{value:"Inherited Types",id:"inherited-types",level:3},{value:"Downcasts",id:"downcasts",level:3},{value:"Upcasts",id:"upcasts",level:3},{value:"Compile-Time Checking",id:"compile-time-checking",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"templates"},"Templates"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Design polymorphic objects to amplify the reusability of code"),(0,i.kt)("li",{parentName:"ul"},"Introduce function and class templates"),(0,i.kt)("li",{parentName:"ul"},"Introduce constrained casting to improve type safety")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'"Templates are of great utility to programmers in C++, especially when combined with multiple inheritance and operator overloading." ',(0,i.kt)("strong",{parentName:"p"},"Wikipedia, 2013."))),(0,i.kt)("p",null,"Polymorphism is not restricted to related types in object-oriented languages. Many languages also support selection across unrelated types. This polymorphism, which perfects the separation of interfaces from implementations, is called parametric or generic polymorphism. In parametric polymorphism the type and the logic executed on that type are independent of one another. Different clients can access the same logic using different totally unrelated types."),(0,i.kt)("p",null,"The C++ language implements parametric polymorphism using template syntax. The compiler generates the implementation for each client type at compile-time from the template defined by the developer."),(0,i.kt)("p",null,"This chapter describes how to implement parametric polymorphism using template syntax with reference to functions and classes. This chapter also describes the templated keywords available for casting values from one type to another."),(0,i.kt)("h2",{id:"function-template"},"Function Template"),(0,i.kt)("h3",{id:"template-syntax"},"Template Syntax"),(0,i.kt)("p",null,"A template definition resembles that of a global function with the parentheses replaced by angle brackets. A template header takes the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template<Type identifier[, ...]>\n")),(0,i.kt)("p",null,"The keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"template")," identifies the subsequent code block as a template. The less-than greater-than angle bracket pair (",(0,i.kt)("inlineCode",{parentName:"p"},"<>"),") encloses the parameter definitions for the template. The ellipsis denotes more comma-separated parameters. ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," is a placeholder for the argument specified by the client."),(0,i.kt)("p",null,"Each parameter declaration consists of a type and an identifier. ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," may be any of"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"typename"),": To identify a type (fundamental or compound)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"class"),": To identify a type (fundamental or compound)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"short"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"char"),": To identify a non-floating-point fundamental type"),(0,i.kt)("li",{parentName:"ul"},"a template parameter")),(0,i.kt)("p",null,"The following examples are equivalent to one another:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\n\n// ... template body follows here\n\n    T value; // value is of type T\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class T>\n\n// ... template body follows here\n\n    T value; // value is of type T\n")),(0,i.kt)("p",null,"The compiler replaces ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," with the argument specified by the client code."),(0,i.kt)("h3",{id:"complete-definition"},"Complete Definition"),(0,i.kt)("p",null,"Consider the following function that swaps values in two different memory locations. This code is defined using references to two ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void swap(int& a, int& b) {\n    int c;\n    c = a;\n    a = b;\n    b = c;\n}\n")),(0,i.kt)("p",null,"The template for all functions that swap values in this way follows from replacing the specific type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," with the type variable ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," and inserting the template header:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Template for swap\n// swap.h\n\ntemplate<typename T>\nvoid swap(T& a, T& b) {\n    T c;\n    c = a;\n    a = b;\n    b = c;\n}\n")),(0,i.kt)("p",null,"We place template definitions in header files; in this case, in ",(0,i.kt)("inlineCode",{parentName:"p"},"swap.h"),"."),(0,i.kt)("h3",{id:"calling-a-templated-function"},"Calling a Templated Function"),(0,i.kt)("p",null,"A call to a templated function determines the specialization that the compiler generates. The compiler binds the call to that specialization."),(0,i.kt)("p",null,"For example, to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"swap()")," function for two ",(0,i.kt)("inlineCode",{parentName:"p"},"double"),"s and two ",(0,i.kt)("inlineCode",{parentName:"p"},"long"),"s, we write the following and leave the remaining work to the compiler:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Calling a Templated Function\n// swap.cpp\n\n#include <iostream>\n#include "swap.h" // template definition\n\nint main() {\n    double a = 2.3;\n    double b = 4.5;\n    long   d = 78;\n    long   e = 567;\n\n    swap(a, b); // compiler generates\n                // swap(double, double)\n\n    std::cout << "Swapped values are " <<\n        a << " and " << b << std::endl;\n\n    swap(d, e); // compiler generates\n                // swap(long, long)\n\n    std::cout << "Swapped values are " <<\n        d << " and " << e << std::endl;\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Swapped values are 4.5 and 2.3\nSwapped values are 567 and 78\n")),(0,i.kt)("p",null,"If the arguments in each call are unambiguous in their type, the compiler can specialize the template appropriately. If the arguments are ambiguous, the compiler reports an error."),(0,i.kt)("h2",{id:"class-template"},"Class Template"),(0,i.kt)("p",null,"The syntax for class templates is similar to that for function templates."),(0,i.kt)("p",null,"The following template defines ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," classes of specified size in static memory. The template parameters are the type (",(0,i.kt)("inlineCode",{parentName:"p"},"T"),") of each element in the array and the number of elements in the array (",(0,i.kt)("inlineCode",{parentName:"p"},"N"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Template for Array Classes\n// Array.h\n\ntemplate <class T, int N>\nclass Array {\n    T a[N];\npublic:\n    T& operator[](int i) { return a[i]; }\n};\n")),(0,i.kt)("p",null,"For the following code, the compiler generates the class definition for an array of element type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and size ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," template definition. The output from executing this client program is shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Class Template\n// Template.cpp\n\n#include <iostream>\n#include \"Array.h\"\n\nint main() {\n    Array<int, 5> a, b;\n\n    for (int i = 0; i < 5; i++)\n        a[i] = i * i;\n\n    b = a;\n\n    for (int i = 0; i < 5; i++)\n        std::cout << b[i] << ' ';\n    std::cout << std::endl;\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"0 1 4 9 16\n")),(0,i.kt)("h2",{id:"constrained-casts"},"Constrained Casts"),(0,i.kt)("p",null,"Constrained casts improve type safety. Type safety is an important feature of any strongly typed language. Bypassing the type system introduces ambiguity to the language itself and is best avoided. Casting a value from one type to another type circumvents the type system's type checking facilities. It is good programming practice to implement casts only where absolutely unavoidable and localize them as much as possible."),(0,i.kt)("p",null,"C++ supports constrained type casting through template syntax using one of the following keywords:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static_cast<Type>(expression)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reinterpret_cast<Type>(expression)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"const_cast<Type>(expression)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dynamic_cast<Type>(expression)"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Type")," specifies the destination type. ",(0,i.kt)("inlineCode",{parentName:"p"},"expression")," refers to the value to be cast to the destination type."),(0,i.kt)("h3",{id:"related-types"},"Related Types"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"static_cast<Type>(expression)")," keyword converts the expression from its evaluated type to the specified type. By far, this is the most common form of constrained cast."),(0,i.kt)("p",null,"For example, to cast ",(0,i.kt)("inlineCode",{parentName:"p"},"minutes")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"float")," type, we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Cast to a Related Type\n// static_cast.cpp\n\n#include <iostream>\n\nint main() {\n    double hours;\n    int minutes;\n\n    std::cout << "Enter minutes : ";\n    std::cin >> minutes;\n    hours = static_cast<double>(minutes)/ 60;  // int and float are related\n    std::cout << "In hours, this is " << hours;\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"static_cast<Type>(expression)")," performs limited type checking. It rejects conversions between pointer and non-pointer types."),(0,i.kt)("p",null,"For example, the following constrained cast generates a compile-time error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\nint main() {\n    int x = 2;\n    int* p;\n\n    p = static_cast<int*>(x);  // FAILS: unrelated types\n\n    std::cout << p;\n}\n")),(0,i.kt)("p",null,"Some static casts are portable across different platforms."),(0,i.kt)("h3",{id:"unrelated-types"},"Unrelated Types"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"reinterpret_cast<Type>(expression)")," keyword converts the expression from its evaluated type to an unrelated type. This cast may produce a value that has the same bit pattern as the evaluated expression."),(0,i.kt)("p",null,"For example, to cast an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," type to a pointer to an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," type, we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Cast to an Unrelated Type\n// reinterpret_cast.cpp\n\n#include <iostream>\n\nint main( ) {\n    int x = 2;\n    int* p;\n\n    p = reinterpret_cast<int*>(x);  // int and int* are unrelated\n\n    std::cout << p;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"reinterpret_cast<Type>(expression)")," performs minimal type checking. It rejects conversions between related types."),(0,i.kt)("p",null,"For example, the following constrained cast generates a compile-time error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\nint main( ) {\n    int x = 2;\n    double y;\n\n    y = reinterpret_cast<double>(x);  // FAILS types are related\n\n    std::cout << y;\n}\n")),(0,i.kt)("p",null,"Few reinterpret casts are portable. Uses include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Evaluating raw data"),(0,i.kt)("li",{parentName:"ul"},"Recovering data where types are unknown"),(0,i.kt)("li",{parentName:"ul"},"Quick and messy calculations")),(0,i.kt)("h3",{id:"unmodifiable-types"},"Unmodifiable Types"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"const_cast<Type>(expression)")," keyword removes the ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," status from an expression."),(0,i.kt)("p",null,"A common use case for this constrained cast is a function written by another programmer that does not receive a ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," parameter but should receive one. If we cannot call the function with a const argument, we temporarily remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," status and hope that the function is truly read only."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Strip const status from an Expression\n// const_cast.cpp\n\n#include <iostream>\n\nvoid foo(int* p) {\n    std::cout << *p << std::endl;\n}\n\nint main( ) {\n    const int x = 3;\n    const int* a = &x;\n    int* b;\n\n    // foo expects int* and not const int*\n    b = const_cast<int*>(a);  // remove const status\n    foo(b);\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"const_cast<Type>(expression)")," performs minimal type checking. It rejects conversions between different types."),(0,i.kt)("p",null,"For example, the following code generates a compile-time error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\nint main( ) {\n    const int x = 2;\n    double y;\n\n    y = const_cast<double>(x); // FAILS\n\n    std::cout << y;\n}\n")),(0,i.kt)("h3",{id:"inherited-types"},"Inherited Types"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"The dynamic_cast<Type>(expression)")," keyword converts the value of an expression from its type to another type within the same class hierarchy and performs some type checking."),(0,i.kt)("h3",{id:"downcasts"},"Downcasts"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"dynamic_cast<Type>(expression)")," rejects a downcast from a base class pointer to a derived class pointer if a mismatch occurs or the object cannot be derived from the expression type. The result of a dynamic cast must be tested to ensure that the conversion was successful."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Downcast within the Hierarchy\n// downcast.cpp\n\n#include <iostream>\n\nclass Base {\npublic:\n    virtual void display() const { std::cout << "Base\\n"; }\n};\nclass Derived : public Base {\npublic:\n    void display() const { std::cout << "Derived\\n"; }\n};\n\nint main( ) {\n    Base* b1 = new Base;\n    Base* b2 = new Derived;\n    Derived* d1 = dynamic_cast<Derived*>(b1);\n    Derived* d2 = dynamic_cast<Derived*>(b2);\n\n    if (d1 != nullptr)\n        d1->display();\n    else\n        std::cerr << "d1 is not derived" << std::endl;\n\n    if (d2 != nullptr)\n        d2->display();\n    else\n        std::cerr << "d2 is not derived" << std::endl;\n\n    delete b1\n    delete d2;\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"d1 is not derived\nDerived\n")),(0,i.kt)("h3",{id:"upcasts"},"Upcasts"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"dynamic_cast<Type>(expression)")," rejects an upcast from a derived class pointer to a base class pointer if a mismatch occurs or the object is not derived from the expression type. The result of a dynamic cast must be tested to ensure that the conversion was successful."),(0,i.kt)("p",null,"For example, to cast a derived class pointer to a base object d to a pointer to its base class part, we write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Upcast within the Hierarchy\n// upcast.cpp\n\n#include <iostream>\n\nclass Base {\npublic:\n    void display() const { std::cout << "Base\\n"; }\n};\nclass Derived : public Base {\npublic:\n    void display() const { std::cout << "Derived\\n"; }\n};\n\nint main( ) {\n    Base* b;\n    Derived* d = new Derived;\n\n    b = dynamic_cast<Base*>(d);  // in the same hierarchy\n    if (b != nullptr)\n        b->display();\n    else\n        std::cerr << "Mismatch" << std::endl;\n    d->display();\n    delete d;\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Base\nDerived\n")),(0,i.kt)("p",null,"Note that here the ",(0,i.kt)("inlineCode",{parentName:"p"},"display()")," member function is not ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual"),". If it were, both calls to it would produce the same result."),(0,i.kt)("h3",{id:"compile-time-checking"},"Compile-Time Checking"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"dynamic_cast<Type>(expression)")," performs some compile-time type checking. It rejects conversions from a base class pointer to a derived class pointer if the object is monomorphic; that is, if the base class is not a polymorphic type."),(0,i.kt)("p",null,"For example, the following constrained cast generates a compile-time error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Dynamic Cast - Compile Time Checking\n// dynamic_cast.cpp\n\n#include <iostream>\n\nclass Base {\npublic:\n    void display() const { std::cout << "Base\\n"; }\n};\nclass Derived : public Base {\npublic:\n    void display() const { std::cout << "Derived\\n"; }\n};\n\nint main( ) {\n    Base* b = new Base;\n    Derived* d;\n\n    d = dynamic_cast<Derived*>(b);  // FAILS\n    b->display();\n    d->display();\n    delete d;\n}\n')),(0,i.kt)("p",null,"Note that a ",(0,i.kt)("inlineCode",{parentName:"p"},"static_cast")," works here and may produce the result shown below. However, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Derived")," part of the object would then be incomplete. ",(0,i.kt)("inlineCode",{parentName:"p"},"static_cast")," does not check if the object is complete, leaving the responsibility to the programmer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Static Cast - Compile Time Checking\n// static_cast.cpp\n\n#include <iostream>\n\nclass Base {\npublic:\n    void display() const { std::cout << "Base\\n"; }\n};\nclass Derived : public Base {\npublic:\n    void display() const { std::cout << "Derived\\n"; }\n};\n\nint main( ) {\n    Base* b = new Base;\n    Derived* d;\n\n    d = static_cast<Derived*>(b);  // OK\n    b->display();\n    d->display();\n    delete d;\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Base\nDerived\n")),(0,i.kt)("p",null,"Note that if ",(0,i.kt)("inlineCode",{parentName:"p"},"display()")," is declared virtual the output may be the same for both calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"display()"),"."),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A template header consists of the keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"template")," followed by the template parameters"),(0,i.kt)("li",{parentName:"ul"},"The compiler generates the template specialization based on the argument types in the function call"),(0,i.kt)("li",{parentName:"ul"},"Avoid type casting that completely bypasses the language's type-checking facilities"),(0,i.kt)("li",{parentName:"ul"},"If type casting is necessary, use one of the four type cast keywords (usually ",(0,i.kt)("inlineCode",{parentName:"li"},"static_cast"),")")),(0,i.kt)("h2",{id:"exercises"},"Exercises"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Read the Wikipedia article on ",(0,i.kt)("a",{parentName:"li",href:"http://en.wikipedia.org/wiki/Template_%28programming%29"},"Templates"))))}m.isMDXComponent=!0}}]);