"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[864],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return y}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=o,y=p["".concat(s,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(y,i(i({ref:t},c),{},{components:n})):a.createElement(y,i({ref:t},c))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8922:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return u}});var a=n(3117),o=(n(7294),n(3905));const r={id:"types-overloading-and-references",title:"Types, Overloading and References",sidebar_position:1,description:"TBD"},i="Types, Overloading and References",l={unversionedId:"B-Foundations/types-overloading-and-references",id:"B-Foundations/types-overloading-and-references",title:"Types, Overloading and References",description:"TBD",source:"@site/docs/B-Foundations/types-overloading-and-references.md",sourceDirName:"B-Foundations",slug:"/B-Foundations/types-overloading-and-references",permalink:"/B-Foundations/types-overloading-and-references",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/B-Foundations/types-overloading-and-references.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"types-overloading-and-references",title:"Types, Overloading and References",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Modular Programming",permalink:"/A-Introduction/modular-programming"},next:{title:"Dynamic Memory",permalink:"/B-Foundations/dynamic-memory"}},s={},u=[{value:"TYPES",id:"types",level:2},{value:"Fundamental Types",id:"fundamental-types",level:3},{value:"bool",id:"bool",level:4},{value:"bool to int",id:"bool-to-int",level:5},{value:"Compound Types",id:"compound-types",level:2},{value:"C++ example",id:"c-example",level:3},{value:"C example",id:"c-example-1",level:3},{value:"<code>auto</code> Keyword",id:"auto-keyword",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"types-overloading-and-references"},"Types, Overloading and References"),(0,o.kt)("p",null,"Part B - Foundations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Review types, declarations, definitions and scoping"),(0,o.kt)("li",{parentName:"ul"},"Introduce overloading and function signatures"),(0,o.kt)("li",{parentName:"ul"},"Introduce pass by reference and compare it to pass by address")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'Correctness, simplicity, and clarity comes first" (Sutter, Alexandrescu, 2005)')),(0,o.kt)("p",null,"Object-oriented languages inherit from their non-object-oriented predecessors the concepts of variable declarations, data types, data structures, logic constructs, and modular programming. The C++ language inherits these features from the C language (see ",(0,o.kt)("a",{parentName:"p",href:"https://intro2c.sdds.ca/"},"IPC Notes")," for a detailed exposition)."),(0,o.kt)("p",null,"This chapter elaborates on these inherited concepts and introduces the new concepts of references and overloading, which the C++ language adds to its C core. This chapter concludes with a section on arrays of pointers, which is important later in the design of polymorphic objects."),(0,o.kt)("h2",{id:"types"},"TYPES"),(0,o.kt)("p",null,"The built-in types of the C++ language are called its fundamental types. The C++ language, like C, admits struct types constructed from these fundamental types and possibly other struct types. The C++ language standard refers to struct types as compound types. (The C language refers to struct types as derived types.)"),(0,o.kt)("h3",{id:"fundamental-types"},"Fundamental Types"),(0,o.kt)("p",null,"The fundamental types of C++ include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Integral Types (store data exactly in equivalent binary form and can be signed or unsigned)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"bool - not available in C"),(0,o.kt)("li",{parentName:"ul"},"char"),(0,o.kt)("li",{parentName:"ul"},"int - short, long, long long"))),(0,o.kt)("li",{parentName:"ul"},"Floating Point Types (store data to a specified precision - can store very small and very large values)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"float"),(0,o.kt)("li",{parentName:"ul"},"double - long double")))),(0,o.kt)("h4",{id:"bool"},"bool"),(0,o.kt)("p",null,"The bool type stores a logical value: true or false."),(0,o.kt)("p",null,"The ! operator reverses that value: !true is false and !false is true."),(0,o.kt)("p",null,"! is self-inverting on bool types, but not self-inverting on other types."),(0,o.kt)("h5",{id:"bool-to-int"},"bool to int"),(0,o.kt)("p",null,"Conversions from bool type to any integral type and vice versa require care. true promotes to an int of value 1, while false promotes to an int of value 0. Applying the ! operator to an int value other than 0 produces a value of 0, while applying the ! operator to an int value of 0 produces a value of 1. Note that the following code snippet displays 1 (not 4)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C++"},"int x = 4;\ncout << !!x;\n\n")),(0,o.kt)("p",null,"Output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"1\n")),(0,o.kt)("p",null,"Both C and C++ treat the integer value 0 as false and any other value as true."),(0,o.kt)("h2",{id:"compound-types"},"Compound Types"),(0,o.kt)("p",null,"A compound type is a type composed of other types. A struct is a compound type. An object-oriented class is also a compound type. To identify a compound type we use the keywords struct or class. We cover the syntax for classes in the following chapter."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"// Modular Example\n// Transaction.h\n\nstruct Transaction {\n    int acct;      // account number\n    char type;     // credit 'c' debit 'd'\n    double amount; // transaction amount\n};\n")),(0,o.kt)("p",null,"The C++ language requires the keyword identifying a compound type only in the declaration of that type. The language does not require the keyword struct or class in a function prototype or an object definition. Note the first code snippet below. Recall that the C language requires the keyword struct throughout the code as listed in the code snippet for C example below."),(0,o.kt)("h3",{id:"c-example"},"C++ example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C++"}," // Modular Example - C++\n // Transaction.h\n\n struct Transaction {\n     int acct;\n     char type;\n     double amount;\n };\n void enter(Transaction*);\n void display(const Transaction*);\n // ...\n\n int main() {\n     Transaction tr;\n     // ...\n }\n")),(0,o.kt)("h3",{id:"c-example-1"},"C example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C"}," // Modular Example - C\n // Transaction.h\n\n struct Transaction {\n     int acct;\n     char type;\n     double amount;\n };\n void enter(struct Transaction*);\n void display(const struct Transaction*);\n // ...\n\n int main() {\n     struct Transaction tr;\n     // ...\n }\n")),(0,o.kt)("h2",{id:"auto-keyword"},(0,o.kt)("inlineCode",{parentName:"h2"},"auto")," Keyword"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"auto")," keyword was introduced in the C++11 standard. This keyword deduces the object's type directly from its initializer's type. We must provide the initializer in any ",(0,o.kt)("inlineCode",{parentName:"p"},"auto")," declaration."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C++"},"     auto x = 4;   // x is an int that is initialized to 4\n     auto y = 3.5; // y is a double that is initialized to 3.5\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"auto")," is quite useful: it simplifies our coding by using information that the compiler already has."))}p.isMDXComponent=!0}}]);