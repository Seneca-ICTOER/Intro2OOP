"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[55],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return g}});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=a,g=d["".concat(l,".").concat(m)]||d[m]||p[m]||r;return t?o.createElement(g,i(i({ref:n},u),{},{components:t})):o.createElement(g,i({ref:n},u))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9944:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return i},default:function(){return d},frontMatter:function(){return r},metadata:function(){return s},toc:function(){return c}});var o=t(3117),a=(t(7294),t(3905));const r={id:"classes-and-resources",title:"Classes and Resources",sidebar_position:4,description:"TBD"},i="Classes and Resources",s={unversionedId:"C-Encapsulation/classes-and-resources",id:"C-Encapsulation/classes-and-resources",title:"Classes and Resources",description:"TBD",source:"@site/docs/C-Encapsulation/classes-and-resources.md",sourceDirName:"C-Encapsulation",slug:"/C-Encapsulation/classes-and-resources",permalink:"/C-Encapsulation/classes-and-resources",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/C-Encapsulation/classes-and-resources.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"classes-and-resources",title:"Classes and Resources",sidebar_position:4,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Member Operators",permalink:"/C-Encapsulation/member-operators"},next:{title:"Helper Functions",permalink:"/C-Encapsulation/helper-functions"}},l={},c=[{value:"Resource Instance Pointers",id:"resource-instance-pointers",level:2},{value:"Case Study",id:"case-study",level:3},{value:"Deep Copies and Assignments",id:"deep-copies-and-assignments",level:2},{value:"Copy Constructor",id:"copy-constructor",level:2},{value:"Declaration",id:"declaration",level:3},{value:"Definition",id:"definition",level:3},{value:"Copy Assignment Operator",id:"copy-assignment-operator",level:2},{value:"Declaration",id:"declaration-1",level:3},{value:"Definition",id:"definition-1",level:3},{value:"Localization",id:"localization",level:2},{value:"Private Member Function",id:"private-member-function",level:3},{value:"Direct Call",id:"direct-call",level:3},{value:"Assigning Temporary Objects",id:"assigning-temporary-objects",level:3},{value:"Copies Prohibited",id:"copies-prohibited",level:2},{value:"Summary",id:"summary",level:2}],u={toc:c};function d(e){let{components:n,...r}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"classes-and-resources"},"Classes and Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Design classes with dynamically allocated resources to model the components of a programming solution"),(0,a.kt)("li",{parentName:"ul"},"Define the copy constructor and assignment operator for a class with a resource")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},'"Never allocate more than one resource in a single statement" ',(0,a.kt)("strong",{parentName:"p"},"Sutter, Alexandrescu, 2005."))),(0,a.kt)("p",null,"In object-oriented programming, we design classes to behave independently of their client applications. Wherever client code dictates the amount of memory that an object requires, the memory that needs to be allocated is unknown at compile-time. Only once the client has instantiated the object will the object know how much memory the client requires. To review run-time memory allocation and deallocation see the chapter entitled ",(0,a.kt)("a",{parentName:"p",href:"/B-Foundations/dynamic-memory"},"Dynamic Memory"),"."),(0,a.kt)("p",null,"Memory that an object allocates at run-time represents a resource to its class. Management of this resource requires additional logic that was unnecessary in simpler designs. This additional logic ensures proper handling of the resource and is often called deep copying and deep assignment."),(0,a.kt)("p",null,"This chapter describes how to implement deep copying and deep assignment logic. The member functions that manage resources are the constructors, the assignment operator and the destructor."),(0,a.kt)("h2",{id:"resource-instance-pointers"},"Resource Instance Pointers"),(0,a.kt)("p",null,"A C++ object refers to a resource through a resource instance pointer. This pointer holds the address of the resource. The address lies outside the object's static memory."),(0,a.kt)("h3",{id:"case-study"},"Case Study"),(0,a.kt)("p",null,"Let us upgrade our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class to accommodate a variable number of grades. The client code specifies the number at run-time. The array of grades is now a dynamically allocated resource. We allocate:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"static memory for the resource instance variable (grade)"),(0,a.kt)("li",{parentName:"ul"},"dynamic memory for the grade array itself")),(0,a.kt)("p",null,"In this section, we focus on the constructors and the destructor for our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class. Let us assume that the client does not copy or assign objects of this class. We shall cover the copying and assignment logic in subsequent sections:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Resources - Constructor and Destructor\n// resources.cpp\n\n#include <iostream>\nusing namespace std;\n\nclass Student {\n    int no;\n    float* grade;\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(int, const float*, int);\n    ~Student();\n    void display() const;\n};\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n    grade = nullptr;\n}\n\nStudent::Student(int sn) {\n    float g[] = {0.0f};\n    grade = nullptr;\n    *this = Student(sn, g, 0);\n}\n\nStudent::Student(int sn, const float* g, int ng_) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_;\n        // allocate dynamic memory\n        if (ng > 0) {\n            grade = new float[ng];\n            for (int i = 0; i < ng; i++)\n                grade[i] = g[i];\n        } else {\n            grade = nullptr;\n        }\n    } else {\n        grade = nullptr;\n        *this = Student();\n    }\n}\n\nStudent::~Student() {\n    delete [] grade;\n}\n\nvoid Student::display() const {\n    if (no > 0) {\n        cout << no << ":\\n";\n        cout.setf(ios::fixed);\n        cout.precision(2);\n        for (int i = 0; i < ng; i++) {\n            cout.width(6);\n            cout << grade[i] << endl;\n        }\n        cout.unsetf(ios::fixed);\n        cout.precision(6);\n    } else {\n        cout << "no data available" << endl;\n    }\n}\n\nint main () {\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry(1234, gh, 3);\n    harry.display();\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"1234:\n 89.40\n 67.80\n 45.50\n")),(0,a.kt)("p",null,"The no-argument constructor places the object in a safe empty state. The three-argument constructor allocates dynamic memory for the resource only if the data received is valid. The pre-initialization of ",(0,a.kt)("inlineCode",{parentName:"p"},"grade")," is a precaution that ensures no inadvertent destruction of memory (see the assignment operator section below). The destructor deallocates any memory that the constructor allocated. Deallocating memory at the ",(0,a.kt)("inlineCode",{parentName:"p"},"nullptr")," address has no effect."),(0,a.kt)("h2",{id:"deep-copies-and-assignments"},"Deep Copies and Assignments"),(0,a.kt)("p",null,"In designing a class with a resource, we expect the resource associated with one object to be independent of the resource associated with another object. That is, if we change the resource data in one object, we expect the resource data in the other object to remain unchanged. In copying and assigning objects we ensure resource independence through deep copying and deep assigning. Deep copying and deep assigning involve copying the resource data. Shallow copying and assigning involve copying the instance variables only and are only appropriate for non-resource instance variables."),(0,a.kt)("p",null,"Implementing deep copying and assigning requires dynamic allocation and deallocation of memory. The copying process includes not only the non-resource instance variables but also the resource data itself."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Deep Copy",src:t(8291).Z,width:"721",height:"241"})),(0,a.kt)("p",null,"In each deep copy, we allocate memory for the underlying resource and copy the contents of the source resource into the destination memory. We shallow copy the instance variables that are NOT resource instance variables. For example, in our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class, we shallow copy the student number and number of grades, but not the address stored in the ",(0,a.kt)("inlineCode",{parentName:"p"},"grade")," pointer."),(0,a.kt)("p",null,"Two special member functions manage allocations and deallocations associated with deep copying and deep copy assigning:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the copy constructor"),(0,a.kt)("li",{parentName:"ul"},"the copy assignment operator")),(0,a.kt)("p",null,"If we do not declare a copy constructor, the compiler inserts code that implements a shallow copy. If we do not declare a copy assignment operator, the compiler inserts code that implements a shallow assignment."),(0,a.kt)("h2",{id:"copy-constructor"},"Copy Constructor"),(0,a.kt)("p",null,"The copy constructor contains the logic for copying from a source object to a newly created object of the same type. The compiler calls this constructor when the client code:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Creates an object by initializing it to an existing object"),(0,a.kt)("li",{parentName:"ol"},"Copies an object by value in a function call"),(0,a.kt)("li",{parentName:"ol"},"Returns an object by value from a function")),(0,a.kt)("h3",{id:"declaration"},"Declaration"),(0,a.kt)("p",null,"The declaration of a copy constructor takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Type(const Type&);\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," is the name of the class."),(0,a.kt)("p",null,"To define a copy constructor, we insert its declaration into the class. For example, we insert the following into the definition of our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp",metastring:"{10} showLineNumbers","{10}":!0,showLineNumbers:!0},"// Student.h\n\nclass Student {\n    int no;\n    float* grade;\n    int ng;\npublic:\n    Student();\n    Student(int, const char*);\n    Student(const Student&);\n    ~Student();\n    void display() const;\n};\n")),(0,a.kt)("h3",{id:"definition"},"Definition"),(0,a.kt)("p",null,"The definition of a copy constructor contains logic to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Perform a shallow copy on all non-resource instance variables"),(0,a.kt)("li",{parentName:"ol"},"Allocate memory for each new resource"),(0,a.kt)("li",{parentName:"ol"},"Copy data from the source resource to the newly created resource")),(0,a.kt)("p",null,"For example, the following code implements a deep copy on objects of our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <iostream>\nusing namespace std;\n#include "Student.h"\n\n// ...\n\nStudent::Student(const Student& src) {\n\n    // shallow copies\n    no = src.no;\n    ng = src.ng;\n\n    // allocate dynamic memory for grades\n    if (src.grade != nullptr) {\n        grade = new float[ng];\n        // copy data from the source resource\n        // to the newly allocated resource\n        for (int i = 0; i < ng; i++)\n            grade[i] = src.grade[i];\n    }\n    else {\n        grade = nullptr;\n    }\n}\n')),(0,a.kt)("p",null,"Since the source data was validated on its original receipt from the client code and privacy constraints have ensured that this data has not been corrupted in the interim, we do not need to revalidate the data in the copy constructor logic."),(0,a.kt)("h2",{id:"copy-assignment-operator"},"Copy Assignment Operator"),(0,a.kt)("p",null,"The copy assignment operator contains the logic for copying data from an existing object to an existing object. The compiler calls this member operator whenever for client code expressions of the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"identifier = identifier\n")),(0,a.kt)("p",null,"identifier refers to the name of an object."),(0,a.kt)("h3",{id:"declaration-1"},"Declaration"),(0,a.kt)("p",null,"The declaration of an assignment operator takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Type& operator=(const Type&);\n")),(0,a.kt)("p",null,"the left ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," is the return type and the right ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," is the type of the source operand."),(0,a.kt)("p",null,"To define the copy assignment operator, we insert its declaration into the class definition. For example, we insert the following declaration into the definition of our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\nclass Student {\n    int no;\n    float* grade;\n    int ng;\npublic:\n    Student();\n    Student(int, const float*, int);\n    Student(const Student&);\n    Student& operator=(const Student&);\n    ~Student();\n    void display() const;\n};\n")),(0,a.kt)("h3",{id:"definition-1"},"Definition"),(0,a.kt)("p",null,"The definition of the copy assignment operator contains logic to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Check for self-assignment"),(0,a.kt)("li",{parentName:"ol"},"Shallow copy the non-resource instance variables to destination variables"),(0,a.kt)("li",{parentName:"ol"},"Deallocate any previously allocated memory for the resource associated with the current object"),(0,a.kt)("li",{parentName:"ol"},"Allocate a new memory for the resource associated with the current object"),(0,a.kt)("li",{parentName:"ol"},"Copy resource data from the source object to the newly allocated memory of the current object"),(0,a.kt)("li",{parentName:"ol"},"For example, the following code performs a deep copy assignment on objects of our Student class:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.cpp\n\n// ...\n\nStudent& Student::operator=(const Student& source) {\n    // check for self-assignment\n    if (this != &source) {\n        // shallow copy non-resource variables\n        no = source.no;\n        ng = source.ng;\n        // deallocate previously allocated dynamic memory\n        delete [] grade;\n        // allocate new dynamic memory, if needed\n        if (source.grade != nullptr) {\n            grade = new float[ng];\n            // copy the resource data\n            for (int i = 0; i < ng; i++)\n                grade[i] = source.grade[i];\n        }\n        else {\n            grade = nullptr;\n        }\n    }\n    return *this;\n}\n")),(0,a.kt)("p",null,"To trap a self-assignment from the client code (",(0,a.kt)("inlineCode",{parentName:"p"},"a = a"),"), we compare the address of the current object to the address of the source object. If the addresses match, we skip the assignment logic altogether. If we neglect to check for self-assignment, the deallocation statement would release the memory holding the resource data and we would lose access to the source resource resulting in our logic failing at ",(0,a.kt)("inlineCode",{parentName:"p"},"grade[i] = source.grade[i]"),"."),(0,a.kt)("h2",{id:"localization"},"Localization"),(0,a.kt)("p",null,"The code in our definition of the copy constructor is identical to most of the code in our definition of the assignment operator. To avoid such duplication and thereby improve maintainability we can localize the logic in a:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Private member function:")," Localize the common code in a private member function and call that member function from both the copy constructor and the copy assignment operator"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Direct call:")," Call the assignment operator directly from the copy constructor")),(0,a.kt)("h3",{id:"private-member-function"},"Private Member Function"),(0,a.kt)("p",null,"The following solution localizes the common code in a private member function named ",(0,a.kt)("inlineCode",{parentName:"p"},"init()")," and calls this function from the copy constructor and the copy assignment operator:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void Student::init(const Student& source) {\n    no = source.no;\n    ng = source.ng;\n    if (source.grade != nullptr) {\n        grade = new float[ng];\n        for (int i = 0; i < ng; i++)\n            grade[i] = source.grade[i];\n    }\n    else {\n        grade = nullptr;\n    }\n}\n\nStudent::Student(const Student& source) {\n    init(source);\n}\n\nStudent& Student::operator=(const Student& source) {\n    if (this != &source) {  // check for self-assignment\n        // deallocate previously allocated dynamic memory\n        delete [] grade;\n        init(source);\n    }\n    return *this;\n}\n")),(0,a.kt)("h3",{id:"direct-call"},"Direct Call"),(0,a.kt)("p",null,"The following solution initializes the resource instance variable in the copy constructor to ",(0,a.kt)("inlineCode",{parentName:"p"},"nullptr")," and calls the copy assignment operator directly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Student::Student(const Student& source) {\n    grade = nullptr;\n    *this = source; // calls assignment operator\n}\n\nStudent& Student::operator=(const Student& source) {\n    if (this != &source) {  // check for self-assignment\n        no = source.no;\n        ng = source.ng;\n        // deallocate previously allocated dynamic memory\n        delete [] grade;\n        // allocate new dynamic memory\n        if (source.grade != nullptr) {\n            grade = new float[ng];\n            // copy resource data\n            for (int = 0; i < ng; i++)\n                grade[i] = source.grade[i];\n        }\n        else {\n            grade = nullptr;\n        }\n    }\n    return *this;\n}\n")),(0,a.kt)("p",null,"Assigning ",(0,a.kt)("inlineCode",{parentName:"p"},"grade")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"nullptr")," in the copy constructor ensures that the assignment operator does not deallocate any memory if called by the copy constructor."),(0,a.kt)("h3",{id:"assigning-temporary-objects"},"Assigning Temporary Objects"),(0,a.kt)("p",null,"Assigning a temporary object to the current object requires additional code if the object manages resources. To prevent the assignment operator from releasing not-as-yet-acquired resources we initialize each resource instance variable to an empty value (",(0,a.kt)("inlineCode",{parentName:"p"},"nullptr"),")."),(0,a.kt)("p",null,"For example, in the constructors for our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," object, we add the highlighted code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Student {\n    int no;\n    float* grade;\n    int ng;\npublic:\n    // ...\n};\n\nStudent::Student() {\nno = 0;\nng = 0;\ngrade = nullptr;\n}\n\nStudent::Student(int n) {\nfloat g[] = {0.0f};\ngrade = nullptr;\n*this = Student(n, g, 0);\n}\n\nStudent::Student(int sn, const float* g, int ng_) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client's data\n        no = sn;\n        ng = ng_;\n        // allocate dynamic memory\n        if (ng > 0) {\n            grade = new float[ng];\n            for (int i = 0; i < ng; i++)\n                grade[i] = g[i];\n        } else {\n            grade = nullptr;\n        }\n    } else {\n        grade = nullptr;\n        *this = Student();\n    }\n}\n")),(0,a.kt)("h2",{id:"copies-prohibited"},"Copies Prohibited"),(0,a.kt)("p",null,"Certain class designs require prohibiting client code from copying or copy assigning any instance of a class. To prohibit copying and/or copy assigning, we declare the copy constructor and/or the copy assignment operator as deleted members of our class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Student {\n    int no;\n    float* grade;\n    int ng;\npublic:\n    Student();\n    Student(int, const float*, int);\n    Student(const Student& source) = delete;\n    Student& operator=(const Student& source) = delete;\n    ~Student();\n    void display() const;\n};\n")),(0,a.kt)("p",null,"The keyword ",(0,a.kt)("inlineCode",{parentName:"p"},"delete")," used in this context has no relation to deallocating dynamic memory."),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A class with resources requires custom definitions of a copy constructor, copy assignment operator and destructor"),(0,a.kt)("li",{parentName:"ul"},"The copy constructor copies data from an existing object to a newly created object"),(0,a.kt)("li",{parentName:"ul"},"The copy assignment operator copies data from an existing object to an existing object"),(0,a.kt)("li",{parentName:"ul"},"Initialization, pass by value, and return by value client code invokes the copy constructor"),(0,a.kt)("li",{parentName:"ul"},"The copy constructor and copy assignment operator should shallow copy only the non-resource instance variables"),(0,a.kt)("li",{parentName:"ul"},"The copy assignment operator should check for self-assignment")))}d.isMDXComponent=!0},8291:function(e,n,t){n.Z=t.p+"assets/images/deepCopy-be350d0a07232667ec5f54997602b8fd.png"}}]);