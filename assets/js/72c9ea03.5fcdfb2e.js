"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[722],{3905:function(n,e,t){t.d(e,{Zo:function(){return d},kt:function(){return m}});var s=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,s)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function r(n,e){if(null==n)return{};var t,s,a=function(n,e){if(null==n)return{};var t,s,a={},o=Object.keys(n);for(s=0;s<o.length;s++)t=o[s],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(s=0;s<o.length;s++)t=o[s],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var l=s.createContext({}),c=function(n){var e=s.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},d=function(n){var e=c(n.components);return s.createElement(l.Provider,{value:e},n.children)},u="mdxType",p={inlineCode:"code",wrapper:function(n){var e=n.children;return s.createElement(s.Fragment,{},e)}},h=s.forwardRef((function(n,e){var t=n.components,a=n.mdxType,o=n.originalType,l=n.parentName,d=r(n,["components","mdxType","originalType","parentName"]),u=c(t),h=a,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||o;return t?s.createElement(m,i(i({ref:e},d),{},{components:t})):s.createElement(m,i({ref:e},d))}));function m(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var o=t.length,i=new Array(o);i[0]=h;var r={};for(var l in e)hasOwnProperty.call(e,l)&&(r[l]=e[l]);r.originalType=n,r[u]="string"==typeof n?n:a,i[1]=r;for(var c=2;c<o;c++)i[c]=t[c];return s.createElement.apply(null,i)}return s.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1589:function(n,e,t){t.r(e),t.d(e,{assets:function(){return l},contentTitle:function(){return i},default:function(){return u},frontMatter:function(){return o},metadata:function(){return r},toc:function(){return c}});var s=t(3117),a=(t(7294),t(3905));const o={id:"functions-in-a-hierarchy",title:"Functions in a Hierarchy",sidebar_position:2,description:"TBD"},i="Functions in a Hierarchy",r={unversionedId:"D-Inheritance/functions-in-a-hierarchy",id:"D-Inheritance/functions-in-a-hierarchy",title:"Functions in a Hierarchy",description:"TBD",source:"@site/docs/D-Inheritance/functions-in-a-hierarchy.md",sourceDirName:"D-Inheritance",slug:"/D-Inheritance/functions-in-a-hierarchy",permalink:"/D-Inheritance/functions-in-a-hierarchy",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/D-Inheritance/functions-in-a-hierarchy.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"functions-in-a-hierarchy",title:"Functions in a Hierarchy",sidebar_position:2,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Derived Classes",permalink:"/D-Inheritance/derived-classes"},next:{title:"Virtual Functions",permalink:"/E-Polymorphism/virtual-functions"}},l={},c=[{value:"Shadowing",id:"shadowing",level:2},{value:"Example",id:"example",level:3},{value:"Good Design Tip",id:"good-design-tip",level:3},{value:"Exposing an Overloaded Member Function (Optional)",id:"exposing-an-overloaded-member-function-optional",level:3},{value:"Example",id:"example-1",level:4},{value:"Constructors",id:"constructors",level:2},{value:"Passing Arguments to a Base Class Constructor",id:"passing-arguments-to-a-base-class-constructor",level:3},{value:"Example",id:"example-2",level:4},{value:"Inheriting Base Class Constructors (Optional)",id:"inheriting-base-class-constructors-optional",level:3},{value:"Example",id:"example-3",level:4},{value:"Destructors",id:"destructors",level:2},{value:"Example",id:"example-4",level:3},{value:"Helper Operators (Optional)",id:"helper-operators-optional",level:2},{value:"Summary",id:"summary",level:2}],d={toc:c};function u(n){let{components:e,...o}=n;return(0,a.kt)("wrapper",(0,s.Z)({},d,o,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"functions-in-a-hierarchy"},"Functions in a Hierarchy"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Relate classes using inheritance hierarchies to minimize the duplication of object code"),(0,a.kt)("li",{parentName:"ul"},"Shadow a base class function using a derived class function"),(0,a.kt)("li",{parentName:"ul"},"Pass initialization data across the constructors of a class hierarchy")),(0,a.kt)("p",null,"The logic that a derived class inherits from its base class is limited to the normal member functions of the base class. A derived class does not by default inherit the constructors, the destructor or the copy assignment operator - that is, the special member functions - of the base class. The special member functions in a class hierarchy define the logic for the creation, destruction and copying of different parts of an object and are necessarily different. A derived class' constructor automatically calls the base class' default constructor. A derived class' destructor automatically calls the base class' destructor. A derived class' copy assignment operator automatically calls the base class' copy assignment operator."),(0,a.kt)("p",null,"This chapter describes how member functions shadow one another in a hierarchy and the order in which constructors and destructors call one another. This chapter shows how to define a derived class' constructor to access a specific base class constructor and how to overload a helper operator for a derived class."),(0,a.kt)("h2",{id:"shadowing"},"Shadowing"),(0,a.kt)("p",null,"A member function of a derived class ",(0,a.kt)("inlineCode",{parentName:"p"},"shadows")," the base class member function with the same identifier. The C++ compiler binds a call to the member function of the derived class, if one exists."),(0,a.kt)("p",null,"To access the base class version of a member function that a derived class version has shadowed, we use scope resolution. A call to a shadowed function takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Base::identifier(arguments)\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"Base")," identifies the class to which the shadowed function belongs."),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"Consider the following hierarchy. The base class and the derived class define distinct versions of the ",(0,a.kt)("inlineCode",{parentName:"p"},"display()")," member function. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class version shadows the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," class version for any object of ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\nconst int NG = 20;\n\nclass Person {\n    char name[NC+1];\npublic:\n    void set(const char* n);\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(int, const float*, int);\n    void display(std::ostream&) const;\n};\n")),(0,a.kt)("p",null,"We access the base class version from the derived version using scope resolution:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std::\n\nvoid Person::set(const char* n) {\n    strncpy(name, n, NC);\n    name[NC] = \'\\0\';\n}\n\nvoid Person::display(std::ostream& os) const {\n    os << name << \' \';\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student(n, g, 0);\n}\n\nStudent::Student(int sn, const float* g, int ng_) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_ < NG ? ng_ : NG;\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        *this = Student();\n    }\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n')),(0,a.kt)("p",null,"The following client code produces the output shown on the right:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Shadowing\n// shadowing.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Person jane;\n    jane.set("Jane Doe");\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry(1234, gh, 3);\n    harry.set("Harry");           // inherited\n    harry.display(std::cout);     // not inherited\n    jane.display(std::cout);\n    std::cout << std::endl;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Harry 1234:\n 89.40\n 67.80\n 45.50\nJane Doe\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"harry.display(std::cout)")," calls ",(0,a.kt)("inlineCode",{parentName:"p"},"Student::display()"),", which calls the shadowed ",(0,a.kt)("inlineCode",{parentName:"p"},"Person::display()"),", while jane.display() calls ",(0,a.kt)("inlineCode",{parentName:"p"},"Person::display()")," directly. The derived version shadows the base version when called on ",(0,a.kt)("inlineCode",{parentName:"p"},"harry"),"."),(0,a.kt)("h3",{id:"good-design-tip"},"Good Design Tip"),(0,a.kt)("p",null,"By calling ",(0,a.kt)("inlineCode",{parentName:"p"},"Person::display()")," within ",(0,a.kt)("inlineCode",{parentName:"p"},"Student::display()"),", we hide the hierarchy from the client code. The ",(0,a.kt)("inlineCode",{parentName:"p"},"main()")," function is hierarchy agnostic."),(0,a.kt)("h3",{id:"exposing-an-overloaded-member-function-optional"},"Exposing an Overloaded Member Function (Optional)"),(0,a.kt)("p",null,"The C++ language shadows member functions on their identifier and not on their signature. To expose an overloaded member function in the base class with the same identifier but a different signature we insert a ",(0,a.kt)("inlineCode",{parentName:"p"},"using")," declaration into the definition of the derived class. A ",(0,a.kt)("inlineCode",{parentName:"p"},"using")," declaration takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cp"},"using Base::identifier;\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"Base")," identifies the base class and ",(0,a.kt)("inlineCode",{parentName:"p"},"identifier")," is the name of the shadowed function."),(0,a.kt)("h4",{id:"example-1"},"Example"),(0,a.kt)("p",null,"Let us overload the ",(0,a.kt)("inlineCode",{parentName:"p"},"display()")," member function in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," class to take two arguments: a modifiable reference to the output stream and the address of a C-style null-terminated character string containing a prefix message. We insert the ",(0,a.kt)("inlineCode",{parentName:"p"},"using")," declaration in the definition of the derived class to expose this member function and any other with the same identifier for objects of the derived class."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\nconst int NG = 20;\n\nclass Person {\n    char name[NC+1];\npublic:\n    void set(const char* n);\n    void display(std::ostream&) const;\n    void display(std::ostream&, const char*) const;\n};\n\nclass Student : public Person {\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(int, const float*, int);\n    void display(std::ostream&) const;\n    using Person::display;\n};\n")),(0,a.kt)("p",null,"We define the overloaded ",(0,a.kt)("inlineCode",{parentName:"p"},"display()")," function for the base class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.cpp\n\n#include <cstring>\n#include \"Student.h\"\nusing namespace std;\n\nvoid Person::set(const char* n) {\n    strncpy(name, n, NC);\n    name[NC] = '\\0';\n}\n\nvoid Person::display(ostream& os) const {\n    os << name << ' ';\n}\n\nvoid Person::display(ostream& os, const char* msg) const {\n    os << msg << name << ' ';\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student(n, nullptr, 0);\n}\n\nStudent::Student(int sn, const float* g, int ng_) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client's data\n        no = sn;\n        ng = ng_ < NG ? ng_ : NG;\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        *this = Student();\n    }\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << \":\\n\";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << \"no data available\" << endl;\n    }\n}\n")),(0,a.kt)("p",null,"The following client produces the result shown on the right:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Overloading and Shadowing\n// overloading.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Person jane;\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry(1234, gh, 3);\n\n    harry.set("Harry");\n    harry.display(std::cout);\n    harry.display(std::cout, "Name is ");\n    std::cout << std::endl;\n    jane.set("Jane Doe");\n    jane.display(std::cout);\n    std::cout << std::endl;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Harry 1234:\n 89.40\n 67.80\n 45.50\nName is Harry\nJane Doe\n")),(0,a.kt)("h2",{id:"constructors"},"Constructors"),(0,a.kt)("p",null,"A derived class does not inherit a base class constructor by default. That is, if we do not declare a constructor in our definition of the derived class, the compiler inserts an empty no-argument constructor by default."),(0,a.kt)("p",null,"The compiler constructs an instance of the derived class in four steps in two distinct stages:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Construct the base class portion of the complete object",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Allocate memory for the instance variables in the order of their declaration"),(0,a.kt)("li",{parentName:"ol"},"Execute the base class constructor"))),(0,a.kt)("li",{parentName:"ol"},"Construct the derived class portion of the object",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Allocate memory for the instance variables in the order of their declaration"),(0,a.kt)("li",{parentName:"ol"},"Execute the derived class constructor")))),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Inheritance Constructors",src:t(7340).Z,width:"447",height:"270"})),(0,a.kt)("p",null,"In our example, let us define a no-argument constructor for the base class. The header file declares the no-argument constructor:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\nconst int NG = 20;\n\nclass Person {\n    char name[NC+1];\npublic:\n    Person();\n    void set(const char* n);\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(int, const float*, int);\n    void display(std::ostream&) const;\n};\n")),(0,a.kt)("p",null,"The implementation file defines the base class constructor:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std;\n\nPerson::Person() {\n    cout << "Person()" << endl;\n    name[0] = \'\\0\';\n}\n\nvoid Person::set(const char* n) {\n    cout << "Person(const char*)" << endl;\n    strncpy(name, n, NC);\n    name[NC] = \'\\0\';\n}\n\nvoid Person::display(ostream& os) const {\n    os << name << \' \';\n}\n\nStudent::Student() {\n    cout << "Student()" << endl;\n    no = 0;\n    ng = 0;\n}\n\nStudent::Student(int n) {\n    cout << "Student(int)" << endl;\n    float g[] = {0.0f};\n    *this = Student(n, g, 0);\n}\n\nStudent::Student(int sn, const float* g, int ng_) {\n    cout << "Student(int, const float*, int)" << endl;\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_ < NG ? ng_ : NG;\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        *this = Student();\n    }\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n')),(0,a.kt)("p",null,"The following client uses this implementation to produce the result shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Derived Class Constructors\n// derivedCtors.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Person jane;\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry(1234, gh, 3);\n\n    harry.set("Harry");\n    harry.display(std::cout);\n\n    jane.set("Jane");\n    jane.display(std::cout);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Person()\nPerson()\nStudent(int, const float*, int);\nPerson(const char*);\nHarry 1234:\n 89.40\n 67.80\n 45.50\nPerson(const char*);\nJane\n")),(0,a.kt)("p",null,"In this example, the compiler constructs the two objects as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Allocates memory for ",(0,a.kt)("inlineCode",{parentName:"li"},"jane"),(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Allocates memory for ",(0,a.kt)("inlineCode",{parentName:"li"},"person")),(0,a.kt)("li",{parentName:"ol"},"The base class constructor initializes ",(0,a.kt)("inlineCode",{parentName:"li"},"person")," to an empty string"))),(0,a.kt)("li",{parentName:"ol"},"Allocates memory for ",(0,a.kt)("inlineCode",{parentName:"li"},"harry")," 1. Allocates memory for ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," 2. The base class constructor initializes ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," to an empty string\nallocates memory for ",(0,a.kt)("inlineCode",{parentName:"li"},"no"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"grade")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"ng")," 3. The derived class constructor initializes: - ",(0,a.kt)("inlineCode",{parentName:"li"},"no")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"1234")," - ",(0,a.kt)("inlineCode",{parentName:"li"},"grade")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"{89.40f, 67.80f, 45.50f}")," - ",(0,a.kt)("inlineCode",{parentName:"li"},"ng")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"3"))),(0,a.kt)("h3",{id:"passing-arguments-to-a-base-class-constructor"},"Passing Arguments to a Base Class Constructor"),(0,a.kt)("p",null,"Each constructor of a derived class, other than the no-argument constructor, receives in its parameters all of the values passed by the client. Each constructor forwards the values for the base class part of the object to the base class constructor. The base class constructor uses the values received to build the base class part of the object. The derived class constructor uses the values received to complete building the derived class part of the object."),(0,a.kt)("p",null,"A call to the base class constructor from a derived class constructor that forwards values takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Derived( parameters ) : Base( arguments )\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"Derived")," is the name of the derived class and ",(0,a.kt)("inlineCode",{parentName:"p"},"Base")," is the name of the base class. The single colon separates the header of the derived-class constructor from its call to the base class constructor. If we omit this call, the compiler inserts a call to the default base class constructor."),(0,a.kt)("h4",{id:"example-2"},"Example"),(0,a.kt)("p",null,"Let us replace the ",(0,a.kt)("inlineCode",{parentName:"p"},"set()")," member function in the base class with a one-argument constructor and upgrade the ",(0,a.kt)("inlineCode",{parentName:"p"},"Student"),"'s three-argument constructor to receive the student's name. The header file declares a single-argument base class constructor and a four-argument derived class constructor:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\nconst int NG = 20;\n\nclass Person {\n    char name[NC+1];\npublic:\n    Person();\n    Person(const char*);\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(const char*, int, const float*, int);\n    void display(std::ostream&) const;\n};\n")),(0,a.kt)("p",null,"The implementation of the single-argument constructor copies the name to the instance variable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std;\n\nPerson::Person() {\n    name[0] = \'\\0\';\n}\n\nPerson::Person(const char* nm) {\n    strncpy(name, nm, NC);\n    name[NC] = \'\\0\';\n}\n\nvoid Person::display(ostream& os) const {\n    os << name << \' \';\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student("", n, g, 0);\n}\n\nStudent::Student(const char* nm, int sn, const float* g, int ng_) : Person(nm) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_ < NG ? ng_ : NG;\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        *this = Student();\n    }\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n')),(0,a.kt)("p",null,"The following client uses this implementation to produce the output shown on the right:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Derived Class Constructors with Arguments\n// drvdCtorsArgs.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Person jane("Jane");\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry("Harry", 1234, gh, 3);\n\n    harry.display(std::cout);\n    jane.display(std::cout);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Harry 1234:\n 89.40\n 67.80\n 45.50\nJane\n")),(0,a.kt)("h3",{id:"inheriting-base-class-constructors-optional"},"Inheriting Base Class Constructors (Optional)"),(0,a.kt)("p",null,"C++11 introduced syntax for inheriting a base class constructor in cases where the derived class constructor does not execute any logic on the instance variables of the derived class and only passes to the base class constructor values received from the client. In such cases, the derived class may inherit the base class constructors."),(0,a.kt)("p",null,"The declaration for inheriting a base class constructor takes the form:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"using Base::Base;\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"Base")," is the name of the base class."),(0,a.kt)("h4",{id:"example-3"},"Example"),(0,a.kt)("p",null,"Let us derive an ",(0,a.kt)("inlineCode",{parentName:"p"},"Instructor")," class from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," base class and inherit all of the constructors of the base class. The header file overrides the no-inheritance default:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n// compiles with GCC 4.8 or greater or equivalent\n\n#include <iostream>\nconst int NC = 30;\nconst int NG = 20;\n\nclass Person {\n    char name[NC+1];\npublic:\n    Person();\n    Person(const char*);\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(const char*, int, const float*, int);\n    void display(std::ostream&) const;\n};\n\nclass Instructor : public Person {\npublic:\n    using Person::Person;\n};\n")),(0,a.kt)("p",null,"The implementation file remains unchanged. The following client uses this new class definition to produce the output shown on the right:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Inherited Constructors\n// inheritCtors.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Instructor john("John");\n    Person jane("Jane");\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry("Harry", 1234, gh, 3);\n    john.display(std::cout);\n    std::cout << std::endl;\n    harry.display(std::cout);\n    jane.display(std::cout);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"}," John\n Harry 1234:\n  89.40\n  67.80\n  45.50\n Jane\n")),(0,a.kt)("h2",{id:"destructors"},"Destructors"),(0,a.kt)("p",null,"A derived class does not inherit the destructor of its base class. Destructors execute in opposite order to the order of their object's construction. That is, the derived class destructor always executes before the base class destructor."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Inheritance Destructors",src:t(4031).Z,width:"429",height:"312"})),(0,a.kt)("h3",{id:"example-4"},"Example"),(0,a.kt)("p",null,"Let us define destructors for our base and derived classes that insert tracking messages to standard output. We declare each destructor in its class definition:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\nconst int NG = 20;\n\nclass Person {\n    char name[NC+1];\npublic:\n    Person();\n    Person(const char*);\n    ~Person();\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(const char*, int, const float*, int);\n    ~Student();\n    void display(std::ostream&) const;\n};\n")),(0,a.kt)("p",null,"We specify the messages in the destructor definitions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std;\n\nPerson::Person() {\n    name[0] = \'\\0\';\n}\n\nPerson::Person(const char* nm) {\n    strncpy(name, nm, NC);\n    name[NC] = \'\\0\';\n}\n\nPerson::~Person() {\n    std::cout << "Leaving " << name << std::endl;\n}\n\nvoid Person::display(ostream& os) const {\n    os << name << \' \';\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student("", n, g, 0);\n}\n\nStudent::Student(const char* nm, int sn, const float* g, int ng_) : Person(nm) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_ < NG ? ng_ : NG;\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        *this = Student();\n    }\n}\n\nStudent::~Student() {\n    std::cout << "\\nLeaving " << no << std::endl;\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n')),(0,a.kt)("p",null,"The following client uses this implementation to produce the output shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Derived Class Destructors\n// drvdDtors.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Person jane("Jane");\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry("Harry", 1234, gh, 3);\n\n    harry.display(std::cout);\n    jane.display(std::cout);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Harry 1234:\n 89.40\n 67.80\n 45.50\nJane\nLeaving 1234\nLeaving Harry\nLeaving Jane\n")),(0,a.kt)("h2",{id:"helper-operators-optional"},"Helper Operators (Optional)"),(0,a.kt)("p",null,"Helper functions support the classes identified by their parameter types. Each helper function is dedicated to the class that it supports. The compiler binds a call to a helper function on the basis of its parameter type(s). That is, the helper functions of a base class do not directly support classes derived from the supported base class."),(0,a.kt)("p",null,"Example"),(0,a.kt)("p",null,"Let us upgrade our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class to include overloads of the insertion and extraction operators for both base and derived classes. The header file contains:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"}," // Student.h\n\n #include <iostream>\n const int NC = 30;\n const int NG = 20;\n\n class Person {\n     char name[NC+1];\n   public:\n     Person();\n     Person(const char*);\n     void display(std::ostream&) const;\n };\n std::istream& operator>>(std::istream&, Person&);\n std::ostream& operator<<(std::ostream&, const Person&);\n\n class Student : public Person {\n     int no;\n     float grade[NG];\n     int ng;\n   public:\n     Student();\n     Student(int);\n     Student(const char*, int, const float*, int);\n     void read(std::istream&);\n     void display(std::ostream&) const;\n };\n std::istream& operator>>(std::istream&, Student&);\n std::ostream& operator<<(std::ostream&, const Student&);\n")),(0,a.kt)("p",null,"The implementation file defines the helper operators:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std;\n\nPerson::Person() {\n    name[0] = \'\\0\';\n}\n\nPerson::Person(const char* nm) {\n    strncpy(name, nm, NC);\n    name[NC] = \'\\0\';\n}\n\nvoid Person::display(ostream& os) const {\n    os << name << \' \';\n}\n\nistream& operator>>(istream& is, Person& p) {\n    char name[NC+1];\n    cout << "Name: ";\n    is.getline(name, NC+1);\n    p = Person(name);\n    return is;\n}\n\nstd::ostream& operator<<(ostream& os, const Person& p) {\n    p.display(os);\n    return os;\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student("", n, g, 0);\n}\n\nStudent::Student(const char* nm, int sn, const float* g, int ng_) : Person(nm) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_ < NG ? ng_ : NG;\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        *this = Student();\n    }\n}\n\nvoid Student::display(std::ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n\nvoid Student::read(istream& is) {\n    char name[NC + 1]; // will hold the student\'s name\n    int no;            // will hold the student\'s number\n    int ng;            // will hold the number of grades\n    float grade[NG];   // will hold the grades\n\n    std::cout << "Name: ";\n    is.getline(name, NC+1);\n    cout << "Student Number : ";\n    is >> no;\n    cout << "Number of Grades : ";\n    is >> ng;\n    if (ng > NG) ng = NG;\n    for (int i = 0; i < ng; i++) {\n        cout << "Grade " << i + 1 << " : ";\n        is >> grade[i];\n    }\n\n    // construct a temporary Student\n    Student temp(name, no, grade, ng);\n    // if data is valid, the temporary object into the current object\n    if (temp.no != 0)\n        *this = temp;\n}\n\nistream& operator>>(istream& is, Student& s) {\n    s.read(is);\n    return is;\n}\n\nostream& operator<<(ostream& os, const Student& s) {\n    s.display(os);\n    return os;\n}\n')),(0,a.kt)("p",null,"The following client uses this implementation to produce the output shown on the right:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Helpers to Derived Classes\n// drvdHelpers.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Person jane;\n    Student harry;\n\n    std::cin >> jane;\n    std::cin >> harry;\n    std::cout << jane << std::endl;\n    std::cout << harry << std::endl;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Name: Jane Doe\nName: Harry\nStudent Number : 1234\nNumber of Grades : 3\nGrade 1 : 89.40\nGrade 2 : 67.80\nGrade 3 : 45.50\nJane Doe\nHarry 1234\n 89.40\n 67.80\n 45.50\n")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A member function of a derived class shadows an identically named member function of a base class"),(0,a.kt)("li",{parentName:"ul"},"A derived class does not inherit the destructor, assignment operators or helper functions of a base class"),(0,a.kt)("li",{parentName:"ul"},"A derived class does not by default inherit the constructor of a base class, but we may add syntax to allow inheritance where the derived class constructor does not contain logic to set its instance variables"),(0,a.kt)("li",{parentName:"ul"},"Constructors in an inheritance hierarchy execute in order from the base class to the derived class"),(0,a.kt)("li",{parentName:"ul"},"Destructors in an inheritance hierarchy execute in order from the derived class to the base class")))}u.isMDXComponent=!0},7340:function(n,e,t){e.Z=t.p+"assets/images/inherit_ctor-1b1dddfb94113575ef21d965a330999f.png"},4031:function(n,e,t){e.Z=t.p+"assets/images/inherit_dtor-a5e47cce8118037b6bc65af710b13632.png"}}]);