"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[222],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7901:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return r},metadata:function(){return s},toc:function(){return c}});var a=n(3117),i=(n(7294),n(3905));const r={id:"language-standards",title:"Language Standards",sidebar_position:3,description:"TBD"},o="Language Standards",s={unversionedId:"F-Refinements/language-standards",id:"F-Refinements/language-standards",title:"Language Standards",description:"TBD",source:"@site/docs/F-Refinements/language-standards.md",sourceDirName:"F-Refinements",slug:"/F-Refinements/language-standards",permalink:"/F-Refinements/language-standards",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/F-Refinements/language-standards.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"language-standards",title:"Language Standards",sidebar_position:3,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Derived Classes and Resources",permalink:"/F-Refinements/derived-classes-and-resources"},next:{title:"Standard Library Functions",permalink:"/Resources-Appendices/standard-library-functions"}},l={},c=[{value:"Milestones",id:"milestones",level:2},{value:"The ISO/IEC Standards",id:"the-isoiec-standards",level:3},{value:"C++98",id:"c98",level:4},{value:"C++11",id:"c11",level:4},{value:"C++14",id:"c14",level:4},{value:"C++17",id:"c17",level:4},{value:"Compiler Support Status",id:"compiler-support-status",level:3},{value:"Some Features That Have Changed",id:"some-features-that-have-changed",level:2},{value:"Inline Functions",id:"inline-functions",level:3},{value:"Example",id:"example",level:4},{value:"Function Deletion",id:"function-deletion",level:3},{value:"The Legacy Way",id:"the-legacy-way",level:4},{value:"C-Style Casts",id:"c-style-casts",level:3},{value:"Plain C-Style Casts",id:"plain-c-style-casts",level:4},{value:"Function-Style Casts",id:"function-style-casts",level:4},{value:"Comparison",id:"comparison",level:4},{value:"Freestore Management",id:"freestore-management",level:3},{value:"The Legacy Way",id:"the-legacy-way-1",level:4},{value:"One Alternative",id:"one-alternative",level:4},{value:"A Technical Note on Inclusion Polymorphism",id:"a-technical-note-on-inclusion-polymorphism",level:3},{value:"Dynamic Dispatch or Late Binding",id:"dynamic-dispatch-or-late-binding",level:4},{value:"Virtual Table",id:"virtual-table",level:4}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"language-standards"},"Language Standards"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Introduce international standards and describe their evolution")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'"C++11 feels like a new language: The pieces just fit together better than they used to and I find a higher-level style of programming more natural than before and as efficient as ever." ',(0,i.kt)("strong",{parentName:"p"},"Stroustrup, 2013."))),(0,i.kt)("p",null,"Object-oriented languages have evolved since the concept of objects was formally incorporated into the Simula language by Ole-Johan Dahl and Kristen Nygaard in the 1960s. International standards have documented their evolution. The most recent standard for the C++ language is formally known as ISO/IEC 14882:2014 and extends over 1300 pages. ISO stands for the International Organization for Standardization. IEC stands for the International Electrotechnical Commission."),(0,i.kt)("p",null,"This chapter reviews the milestones in the evolution of C++, highlights some of the features introduced during its evolution with respect to the original version of the language, and briefly discusses a few of the topics that have evolved with the C++ standards."),(0,i.kt)("h2",{id:"milestones"},"Milestones"),(0,i.kt)("p",null,"C++ was originally designed as a synthesis of C and object-orientation Simula-style. C had and still has no object-oriented capabilities. Simula introduced the terms class, object, inheritance, virtual methods and subclasses (derived classes) formally to the programming community."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.stroustrup.com/"},"Bjarne Stroustrup")," created C++ at Bell Labs (AT&T Research Labs) by augmenting C with the object-oriented features of Simula. He released C++ officially in October 1985. His web site includes a quite useful and up-to-date ",(0,i.kt)("a",{parentName:"p",href:"https://www.stroustrup.com/glossary.html"},"glossary of technical terms"),"."),(0,i.kt)("h3",{id:"the-isoiec-standards"},"The ISO/IEC Standards"),(0,i.kt)("p",null,"At the time of printing, three standard definitions have been approved by the international programming community."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C++98"),(0,i.kt)("li",{parentName:"ul"},"C++11"),(0,i.kt)("li",{parentName:"ul"},"C++14")),(0,i.kt)("h4",{id:"c98"},"C++98"),(0,i.kt)("p",null,"The first official standard that defined the C++ language is formally known as ISO/IEC 14882:1998 and less formally as C++98. The international programming community ratified this definition in 1998 and published it in a document that contains about 800 pages. The definition is based in part on the ISO/IEC 9899:1990 standard for the C language (informally known as C89)."),(0,i.kt)("p",null,"C++98 augmented pre-standard C++ with:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'"additional data types, classes, templates, exceptions, namespaces, inline functions, operator overloading, function name overloading, references, freestore management operators, and additional library facilities."')),(0,i.kt)("p",null,"The library facilities included a newly re-written ",(0,i.kt)("inlineCode",{parentName:"p"},"iostream")," library and the ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," class."),(0,i.kt)("h4",{id:"c11"},"C++11"),(0,i.kt)("p",null,"The second official standard that re-defined the language is formally known as ISO/IEC 14882:2011 and less formally as C++11. The international programming community ratified this definition on August 12 2011. The definition is based on C++98 and C99 and includes several major additions to the core language as well as several major extensions of the standard library."),(0,i.kt)("p",null,"The objectives of the C++11 committee had included:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Making C++ easier to teach and to learn through increased uniformity"),(0,i.kt)("li",{parentName:"ul"},"Making C++ better for systems programming and library construction"),(0,i.kt)("li",{parentName:"ul"},"Improving the type safety of the language")),(0,i.kt)("p",null,"The features that C++11 added to C++98 included (amongst others):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"nullptr")," keyword replacing the ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL")," macro"),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"auto")," keyword inferring the type of a left operand implicitly from the type of the right operand in an assignment expression"),(0,i.kt)("li",{parentName:"ul"},"Inherited constructors"),(0,i.kt)("li",{parentName:"ul"},"Features covered in the next volume of this series of notes",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Move constructors and assignment operators"),(0,i.kt)("li",{parentName:"ul"},"Lambda expressions (anonymous functions)"),(0,i.kt)("li",{parentName:"ul"},"Library support for multi-threading classes"),(0,i.kt)("li",{parentName:"ul"},"Range based for loops"),(0,i.kt)("li",{parentName:"ul"},"Strongly typed enumerations"),(0,i.kt)("li",{parentName:"ul"},"Uniformity amongst initializers"),(0,i.kt)("li",{parentName:"ul"},"Initializers for class members")))),(0,i.kt)("h4",{id:"c14"},"C++14"),(0,i.kt)("p",null,"The third official standard that re-defined the language is formally known as ISO/IEC 14882:2014 and less formally as C++14. The international programming community ratified this definition on August 18 2014. The definition expanded the application of the ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," keyword to return types, the application of templates to variables. The changes made the language safer and more convenient."),(0,i.kt)("p",null,"These notes align with this standard."),(0,i.kt)("h4",{id:"c17"},"C++17"),(0,i.kt)("p",null,"The ISO/IEC 14882 standards committee is working on the next iteration scheduled for ratification in July 2017. The committee intended this revision to be a major amendment to the C++14 standard, but several new features did not make the cut."),(0,i.kt)("h3",{id:"compiler-support-status"},"Compiler Support Status"),(0,i.kt)("p",null,"A language standard is a specification for compiler writers. Different writers introduce different features adopted in a standard at different times. The support status for the features approved in C++11 and C++14 is tabulated at ",(0,i.kt)("a",{parentName:"p",href:"http://en.cppreference.com/w/cpp/compiler_support"},"http://en.cppreference.com/w/cpp/compiler_support"),". Links to the individual compiler web sites are included there."),(0,i.kt)("h2",{id:"some-features-that-have-changed"},"Some Features That Have Changed"),(0,i.kt)("p",null,"Facilities that C++98 and C++11 introduced included inline functions, member function deletion, constrained casting and changes to freestore management."),(0,i.kt)("h3",{id:"inline-functions"},"Inline Functions"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Inlining")," is a technique for improving a function's execution time by replacing the function call with the function logic proper and thereby removing the overhead associated with parameter passing. The primary cost of inlining is an increase in the size of the executable code."),(0,i.kt)("p",null,"An inline request directs the compiler to insert the body of the function at every call to the function, if possible. The compiler, instead of storing the function's definition once in its own dedicated region of memory and transferring control to that region for each call, inserts a copy of the body at each and every call. Inlining is particularly useful with member functions that contain small blocks of code. Member functions that do not contain iterations are candidates for inlining."),(0,i.kt)("p",null,"The compiler determines whether or not to implement an inline request. If the function contains too many statements or an iteration, the compiler ignores the request and calls the function in the usual way."),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)("p",null,"To inline a member function, we embed its definition within the class definition as shown on below or alternatively add the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"inline")," to the definition as shown further below."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Inline Functions - Embedded\n// inline_1.h\n\nconst int NG = 20;\n\nstruct Student {\nprivate:\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    void set(int n, const char* g);\n    const float* getGrades() const {\n        return grade;\n    }\n};\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Inline Functions - Separate\n// inline_2.h\n\nconst int NG = 20;\n\nstruct Student {\nprivate:\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    void set(int n, const char* g);\n    const float* getGrades() const;\n};\ninline const float* Student::getGrades()\nconst {\n    return grade;\n}\n")),(0,i.kt)("p",null,"Note that we place the implementation of an inline function in the header file that includes the class definition."),(0,i.kt)("h3",{id:"function-deletion"},"Function Deletion"),(0,i.kt)("p",null,"C++11 introduced use of the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"delete")," to inform the compiler that we do not want any default definition of a member function created. An example of this usage is the ",(0,i.kt)("a",{parentName:"p",href:"/C-Encapsulation/classes-and-resources#copies-prohibited"},"Copies Prohibited Section")," of the chapter entitled ",(0,i.kt)("a",{parentName:"p",href:"/C-Encapsulation/classes-and-resources"},"Classes and Resoures"),"."),(0,i.kt)("h4",{id:"the-legacy-way"},"The Legacy Way"),(0,i.kt)("p",null,"Prior to C++11, one way to prohibit a client from copying or copy assigning an instance of a class was to declare both the copy constructor and copy assignment operator as private members:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Student {\n    int no;\n    float* grade;\n    int ng;\n    Student(const Student& source);\n    Student& operator=(const Student& source);\npublic:\n    Student();\n    Student(int, const float*);\n    ~Student();\n    void display() const;\n};\n")),(0,i.kt)("p",null,"Since these special member functions were defined as private members, no definition was practically necessary."),(0,i.kt)("h3",{id:"c-style-casts"},"C-Style Casts"),(0,i.kt)("p",null,"C++ inherited its original casting facilities from C directly. The constrained casting syntax described in the chapter entitled ",(0,i.kt)("a",{parentName:"p",href:"/E-Polymorphism/templates"},"Templates")," is more discriminating than the inherited syntax. The standards support the inherited syntax for legacy reasons. The availability of these older features allows programmers to bypass the type system and directly weaken a compiler's ability to identify type errors."),(0,i.kt)("p",null,"For example, consider code that converts an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to a pointer to an ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". Such code is most probably a typing mistake, C and hence C++ allow this code to slip through the type checking system:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int x = 2;\nint* p;\np = (int*)(x); // MOST PROBABLY A TYPING ERROR (& missing)!\n")),(0,i.kt)("p",null,"Nevertheless, in applications built from many thousands of lines of code, we expect the compiler's type-checking system to flag such code. Errors that result from such casts are very difficult to find if they are embedded within many thousands of lines of code."),(0,i.kt)("p",null,"C++ supports old-style casting in two distinct forms - plain C-style casts and C++-function-style casts:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"(Type)identifier\n")),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Type(identfier)\n")),(0,i.kt)("p",null,"These forms are interchangeable for fundamental types, but not pointer types. For conversions to pointer types, only the C-style cast is available."),(0,i.kt)("h4",{id:"plain-c-style-casts"},"Plain C-Style Casts"),(0,i.kt)("p",null,"To cast a value from one type to another using a plain C-style cast, we simply preface the identifier with the name of the target type enclosed in parentheses:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// C-Style Casting\n// c_cast.cpp\n\n#include <iostream>\n\nint main() {\n    double hours;\n    int minutes;\n    std::cout << "Enter minutes : ";\n    std::cin >> minutes;\n    hours = (double) minutes / 60;  // C-Style Cast\n    std::cout << "In hours, this is " << hours;\n}\n')),(0,i.kt)("h4",{id:"function-style-casts"},"Function-Style Casts"),(0,i.kt)("p",null,"To cast a value from one type to another using a function-style cast, we enclose in parentheses the variable or object to be cast to the target type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Function Style Casting\n// functionStyleCast.cpp\n\n#include <iostream>\n\nint main() {\n    double hours;\n    int minutes;\n    std::cout << "Enter minutes : ";\n    std::cin >> minutes;\n    hours = double(minutes) / 60;  // Function-Style Cast\n    std::cout << "In hours, this is " << hours;\n}\n')),(0,i.kt)("h4",{id:"comparison"},"Comparison"),(0,i.kt)("p",null,"The C-style casts (for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"(int)x"),") apply without regard to the nature of the conversion. Such syntax does not convey the programmer's intent."),(0,i.kt)("p",null,"A C-style cast can mean any of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static_cast")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"const_cast")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static_cast")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"const_cast")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reinterpret_cast")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reinterpret_cast")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"const_cast"))),(0,i.kt)("p",null,"The constrained casts distinguish the different categories and thereby improve the degree of type checking available from the compiler."),(0,i.kt)("p",null,"For example, it is always safer type-wise to code a ",(0,i.kt)("inlineCode",{parentName:"p"},"static_cast")," rather than a C-style cast."),(0,i.kt)("h3",{id:"freestore-management"},"Freestore Management"),(0,i.kt)("p",null,"C++98 introduced exception handling for dynamic memory allocation. By default, the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," operator throws an exception if the operator encounters an error. The topic of exception handling is covered in the next volume of this series of notes."),(0,i.kt)("h4",{id:"the-legacy-way-1"},"The Legacy Way"),(0,i.kt)("p",null,"Prior to C++98, the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," operator returned the null address if it encountered an error (for example, insufficient memory)."),(0,i.kt)("p",null,"The following legacy code checks for such an error:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Prior to C++98\n\n#include <iostream.h>\n\nint main() {\n    char* p;\n    int i = 0;\n\n    do {\n        p = new char[100001];\n        i++;\n    } while (p != NULL);\n\n    cout << "Out of space after " << i << " attempts!\\n";\n}\n')),(0,i.kt)("h4",{id:"one-alternative"},"One Alternative"),(0,i.kt)("p",null,"Since C++98, we can instruct the new operator to return the null address by passing the nothrow argument to the operator. nothrow is defined in the new header file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// After C++98 - Null Address Alternative\n\n#include <new>\n#include <iostream>\n\nint main() {\n    char* p;\n    int i = 0;\n\n    do {\n        p = new (std::nothrow) char[100001];\n        i++;\n    } while (p != NULL);\n\n    std::cout << "Out of space after " << i << " attempts!\\n";\n}\n')),(0,i.kt)("p",null,"With C++11, we can improve type safety by replacing the macro NULL with the nullptr keyword:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// After C++11 - Null Address Alternative\n\n#include <new>\n#include <iostream>\n\nint main( ) {\n    char* p;\n    int i = 0;\n\n    do {\n        p = new (std::nothrow) char[100001];\n        i++;\n    } while (p != nullptr);\n\n    std::cout << "Out of space after " << i << " attempts!\\n";\n}\n')),(0,i.kt)("h3",{id:"a-technical-note-on-inclusion-polymorphism"},"A Technical Note on Inclusion Polymorphism"),(0,i.kt)("h4",{id:"dynamic-dispatch-or-late-binding"},"Dynamic Dispatch or Late Binding"),(0,i.kt)("p",null,"The terms dynamic dispatch and late binding arise in descriptions of inclusion polymorphism. These terms have similar definitions and are sometimes used interchangeably. Technically, dynamic dispatch is the more precise term in regard to C++."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Dynamic dispatch")," is the process of selecting which implementation of a member function in a class hierarchy to call on a polymorphic object. The name of the operation may be bound to a polymorphic operation at compile time and the implementation identified at run time. The object's dynamic type determines which implementation to call."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Late binding")," associates a method's name with an object based on its dynamic type. The name of the operation is bound to a polymorphic operation at run time when the implementation is identified. Late binding implies dynamic dispatch."),(0,i.kt)("p",null,"C++ uses early binding and static or dynamic dispatch. Static dispatch is the default. The ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual")," keyword implements dynamic dispatch."),(0,i.kt)("h4",{id:"virtual-table"},"Virtual Table"),(0,i.kt)("p",null,"Most C++ compilers implement dynamic dispatch by adding an instance pointer to the object's data members. This pointer redirects to a table that associates the member function implementations with object types. The run-time code uses this table to select the implementation corresponding to the object's dynamic type. This table is called the ",(0,i.kt)("em",{parentName:"p"},"virtual table")," for the class."),(0,i.kt)("p",null,"The compiler creates the virtual table at compile time. Introducing a virtual table (by inserting the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"virtual"),") results in the equivalent of a single indirection every time a client calls a virtual member function on an instance of its class; that is, it does not introduce a significant overhead. Since the compiler constructs the table at compile time, it is unmodifiable at run-time and we cannot add a new member function to the class at that time."))}p.isMDXComponent=!0}}]);