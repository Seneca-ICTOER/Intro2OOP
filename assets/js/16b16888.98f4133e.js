"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[315],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=c(t),m=a,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||s;return t?r.createElement(h,o(o({ref:n},d),{},{components:t})):r.createElement(h,o({ref:n},d))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[u]="string"==typeof e?e:a,o[1]=i;for(var c=2;c<s;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5046:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return o},default:function(){return u},frontMatter:function(){return s},metadata:function(){return i},toc:function(){return c}});var r=t(3117),a=(t(7294),t(3905));const s={id:"derived-classes-and-resources",title:"Derived Classes and Resources",sidebar_position:2,description:"TBD"},o="Derived Classes and Resources",i={unversionedId:"F-Refinements/derived-classes-and-resources",id:"F-Refinements/derived-classes-and-resources",title:"Derived Classes and Resources",description:"TBD",source:"@site/docs/F-Refinements/derived-classes-and-resources.md",sourceDirName:"F-Refinements",slug:"/F-Refinements/derived-classes-and-resources",permalink:"/F-Refinements/derived-classes-and-resources",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/F-Refinements/derived-classes-and-resources.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"derived-classes-and-resources",title:"Derived Classes and Resources",sidebar_position:2,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Input and Output Refinements",permalink:"/F-Refinements/input-and-output-refinements"},next:{title:"Language Standards",permalink:"/F-Refinements/language-standards"}},l={},c=[{value:"Constructors and Destructors",id:"constructors-and-destructors",level:2},{value:"Example",id:"example",level:3},{value:"Copy Constructor",id:"copy-constructor",level:2},{value:"Example",id:"example-1",level:3},{value:"Copy Assignment Operator",id:"copy-assignment-operator",level:2},{value:"Example",id:"example-2",level:3},{value:"Direct Call Copy Constructor",id:"direct-call-copy-constructor",level:2},{value:"Summary",id:"summary",level:2}],d={toc:c};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"derived-classes-and-resources"},"Derived Classes and Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Design classes with dynamically allocated resources to model the components of a programming solution"),(0,a.kt)("li",{parentName:"ul"},"Define the copy constructor and assignment operator for a derived class with a resource"),(0,a.kt)("li",{parentName:"ul"},"Identify the copy constructor and copy assignment operator defaults for a derived class")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},'"If you use pointers, you have to think about resource management" ',(0,a.kt)("strong",{parentName:"p"},"Stroustrup, 1997."))),(0,a.kt)("p",null,"Inheritance hierarchies that access resources at multiple levels require intervention. Managing relationships between the special member functions in a hierarchy with multiple resources involves ensuring that the appropriate calls between these functions are made. The definitions of some copy constructors and copy assignment operators in the hierarchy may require explicit coding of the connections to their base class counterparts."),(0,a.kt)("p",null,"This chapter describes how to define the constructors and the copy assignment operators in a hierarchy that access multiple resources and how to call their base class counterparts."),(0,a.kt)("h2",{id:"constructors-and-destructors"},"Constructors and Destructors"),(0,a.kt)("p",null,"Each constructor of a derived class calls a constructor of its base class. By default, that constructor is the no-argument constructor. To override this default, we insert an explicit call to the base class constructor."),(0,a.kt)("p",null,"Destructors in an inheritance hierarchy do not require any intervention, since each class in the hierarchy has but one destructor and each destructor calls its sole base class counterpart automatically."),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"Let us upgrade the definition of our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class to accommodate a client-defined number of grades. We store the grades in dynamic memory and store the address of that memory in a resource instance pointer."),(0,a.kt)("p",null,"The upgraded definition of our ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," class contains a resource instance pointer:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\n\nclass Person {\n    char name[NC+1];\npublic:\n    Person();\n    Person(const char*);\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float* grade;\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(const char*, int, const float*, int);\n    ~Student();\n    void display(std::ostream&) const;\n};\n")),(0,a.kt)("p",null,"Our four-argument constructor forwards the student's name to the single-argument constructor of the base class and then allocates memory for the grades. Our destructor deallocates that memory."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std;\n\nPerson::Person() {\n    name[0] = \'\\0\';\n}\n\nPerson::Person(const char* nm) {\n    strncpy(name, nm, NC);\n    name[NC] = \'\\0\';\n}\n\nvoid Person::display(ostream& os) const {\n    os << name << \' \';\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n    grade = nullptr;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student("", n, g, 0);\n}\n\nStudent::Student(const char* nm, int sn, const float* g, int ng_) : Person(nm) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_;\n        if (ng > 0) {\n            grade = new float[ng_];\n            for (int i = 0; i < ng; i++)\n                grade[i] = g[i];\n        } else {\n            grade = nullptr;\n        }\n    } else {\n        grade = nullptr;\n        *this = Student();\n    }\n}\n\nStudent::~Student() {\n    delete [] grade;\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n')),(0,a.kt)("p",null,"The following client uses this implementation to produce the output shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Derived Class with a Resource Constructors\n// dclassResourceCtor.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    Person jane("Jane");\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry("Harry", 1234, gh, 3);\n\n    harry.display(std::cout);\n    jane.display(std::cout);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Harry 1234:\n 89.40\n 67.80\n 45.50\nJane\n")),(0,a.kt)("h2",{id:"copy-constructor"},"Copy Constructor"),(0,a.kt)("p",null,"The copy constructor of a derived class calls a constructor of the base class. By default, that constructor is the no-argument constructor. To override this default, we explicitly call the base class constructor of our choice."),(0,a.kt)("p",null,"The header in the definition of the copy constructor for a derived class takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Derived(const Derived& identifier) : Base(identifier) {\n\n    // ...\n}\n")),(0,a.kt)("p",null,"The parameter receives an unmodifiable reference to an object of the derived class. The argument in the call to the base class' constructor is the parameter's identifier."),(0,a.kt)("p",null,"Copying occurs in two distinct stages and four steps altogether:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Copy the base class part of the existing object",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Allocate memory for the instance variables of the base class in the order of their declaration"),(0,a.kt)("li",{parentName:"ol"},"Execute the base class' copy constructor"))),(0,a.kt)("li",{parentName:"ol"},"Copy the derived class part of the existing object",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Allocate memory for the instance variables of the derived class in the order of their declaration"),(0,a.kt)("li",{parentName:"ol"},"Execute the derived class' copy constructor")))),(0,a.kt)("h3",{id:"example-1"},"Example"),(0,a.kt)("p",null,"Let us declare our own definition of the copy constructor for our Student class, but use the default definition for the Person class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\n\nclass Person {\n    char name[NC+1];\npublic:\n    Person();\n    Person(const char*);\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float* grade;\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(const char*, int, const float*, int);\n    Student(const Student&);\n    ~Student();\n    void display(std::ostream&) const;\n};\n")),(0,a.kt)("p",null,"We implement the copying steps as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Shallow copy the ",(0,a.kt)("inlineCode",{parentName:"li"},"Person")," part of the source object",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Allocate static memory for ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," in the base class part of the newly created object"),(0,a.kt)("li",{parentName:"ol"},"Copy into ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," the string at address ",(0,a.kt)("inlineCode",{parentName:"li"},"src.name")))),(0,a.kt)("li",{parentName:"ol"},"Copy the ",(0,a.kt)("inlineCode",{parentName:"li"},"Student")," part of the source object",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Allocate static memory for ",(0,a.kt)("inlineCode",{parentName:"li"},"no"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"*grade")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"ng")," in the derived part of the newly created object"),(0,a.kt)("li",{parentName:"ol"},"Shallow copy ",(0,a.kt)("inlineCode",{parentName:"li"},"src.no")," into ",(0,a.kt)("inlineCode",{parentName:"li"},"no")),(0,a.kt)("li",{parentName:"ol"},"Shallow copy ",(0,a.kt)("inlineCode",{parentName:"li"},"src.ng")," into ",(0,a.kt)("inlineCode",{parentName:"li"},"ng")),(0,a.kt)("li",{parentName:"ol"},"Allocate dynamic memory for a copy of ",(0,a.kt)("inlineCode",{parentName:"li"},"src.grade")),(0,a.kt)("li",{parentName:"ol"},"Deep copy the elements at ",(0,a.kt)("inlineCode",{parentName:"li"},"src.grade")," into ",(0,a.kt)("inlineCode",{parentName:"li"},"grade"))))),(0,a.kt)("p",null,"The default copy constructor for the base class performs a shallow copy. The copy constructor for the derived class calls the base class copy constructor and performs the deep copy itself:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std;\n\nPerson::Person() {\n    name[0] = \'\\0\';\n}\n\nPerson::Person(const char* nm) {\n    strncpy(name, nm, NC);\n    name[NC] = \'\\0\';\n}\n\nvoid Person::display(ostream& os) const {\n    os << name << \' \';\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n    grade = nullptr;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student("", n, g, 0);\n}\n\nStudent::Student(const char* nm, int sn, const float* g, int ng_) : Person(nm) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_;\n        if (ng > 0) {\n            grade = new float[ng_];\n            for (int i = 0; i < ng; i++)\n                grade[i] = g[i];\n        } else {\n            grade = nullptr;\n        }\n    } else {\n        grade = nullptr;\n        *this = Student();\n    }\n}\n\nStudent::Student(const Student& src) : Person(src) {\n    no = src.no;\n    ng = src.ng;\n    if (src.grade != nullptr && ng > 0) {\n        grade = new float[ng];\n        for (int i = 0; i < ng; i++)\n            grade[i] = src.grade[i];\n    }\n    else\n        grade = nullptr;\n}\n\nStudent::~Student() {\n    delete [] grade;\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Student")," copy constructor executes its logic after the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," copy constructor has executed its logic."),(0,a.kt)("p",null,"The following client uses this implementation to produce the output shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Derived Class with a Resource Copy Constructor\n// dclassResourceCopyCtor.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry("Harry", 1234, gh, 3);\n    Student harrz = harry; // calls copy constructor\n\n    harry.display(std::cout);\n    harrz.display(std::cout);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Harry 1234:\n 89.40\n 67.80\n 45.50\nHarry 1234:\n 89.40\n 67.80\n 45.50\n")),(0,a.kt)("h2",{id:"copy-assignment-operator"},"Copy Assignment Operator"),(0,a.kt)("p",null,"The default copy assignment operator of a derived class calls the copy assignment operator of its base class. However, any custom copy assignment operator of a derived class DOES NOT by default call the copy assignment operator of its base class. Accordingly, a custom copy assignment operator of a derived class with a resource requires an explicit call to the base class copy assignment operator."),(0,a.kt)("p",null,"We call the base class copy assignment operator from within the body of the definition of the derived class assignment operator. The call takes one of the following forms:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The functional form"),(0,a.kt)("li",{parentName:"ul"},"The cast assignment form")),(0,a.kt)("p",null,"The functional expression takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Base::operator=(identifier);\n")),(0,a.kt)("p",null,"The assignment expression takes the form"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"(Base&)*this = identifier;\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Base")," is the name of the base class and ",(0,a.kt)("inlineCode",{parentName:"p"},"identifier")," is the name of the right operand, which is the source object for the assignment. Note that the address of the derived object is the same as the address of the base class part of that object. The compiler distinguishes the call to the base class operator from a call to the derived class operator by the type of the left operand."),(0,a.kt)("h3",{id:"example-2"},"Example"),(0,a.kt)("p",null,"The derived class definition declares the assignment operator and a private member function for the copying operations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream>\nconst int NC = 30;\n\nclass Person {\n    char name[NC+1];\npublic:\n    Person();\n    Person(const char*);\n    void display(std::ostream&) const;\n};\n\nclass Student : public Person {\n    int no;\n    float* grade;\n    int ng;\n    void init(int, int, const float*);\npublic:\n    Student();\n    Student(int);\n    Student(const char*, int, const float*, int);\n    Student(const Student&);\n    Student& operator=(const Student& src);\n    ~Student();\n    void display(std::ostream&) const;\n};\n")),(0,a.kt)("p",null,"The private ",(0,a.kt)("inlineCode",{parentName:"p"},"init()")," contains the copying logic shared by the constructors and the assignment operator:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include <cstring>\n#include "Student.h"\nusing namespace std;\n\nPerson::Person() {\n    name[0] = \'\\0\';\n}\n\nPerson::Person(const char* nm) {\n    strncpy(name, nm, NC);\n    name[NC] = \'\\0\';\n}\n\nvoid Person::display(std::ostream& os) const {\n    os << name << \' \';\n}\n\nvoid Student::init(int no_, int ng_, const float* g) {\n    no = no_;\n    ng = ng_;\n    if (g != nullptr && ng > 0) {\n        grade = new float[ng_];\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        grade = nullptr;\n    }\n}\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n    grade = nullptr;\n}\n\nStudent::Student(int n) {\n    float g[] = {0.0f};\n    *this = Student("", n, g, 0);\n}\n\nStudent::Student(const char* nm, int sn, const float* g, int ng_) : Person(nm) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        init(sn, ng_, g);\n    } else {\n        grade = nullptr;\n        *this = Student();\n    }\n}\n\nStudent::Student(const Student& src) : Person(src) {\n    init(src.no, src.ng, src.grade);\n}\n\nStudent& Student::operator=(const Student& src) {\n    if (this != &src) {\n        // Base class assignment\n        // 1 - functional expression\n        // Person::operator=(src);\n        // 2 - assignment expression\n        (Person&)*this = src; // call base class assignment operator\n        delete [] grade;\n        init(src.no, src.ng, src.grade);\n    }\n    return *this;\n}\n\nStudent::~Student() {\n    delete [] grade;\n}\n\nvoid Student::display(ostream& os) const {\n    if (no > 0) {\n        Person::display(os);\n        os << no << ":\\n";\n        os.setf(ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << endl;\n        }\n        os.unsetf(ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << endl;\n    }\n}\n')),(0,a.kt)("p",null,"Sharing a ",(0,a.kt)("inlineCode",{parentName:"p"},"private")," member function is one way of coding the copy constructor and assignment operator for the derived class."),(0,a.kt)("p",null,"The following client uses this implementation to produce the output shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Derived Class with a Resource Copy Assignment\n// dclassResourceCopyAssmnt.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main() {\n    float gh[] = {89.4f, 67.8f, 45.5f};\n    Student harry("Harry", 1234, gh, 3), harrz;\n    harrz = harry; // calls copy assignment\n\n    harry.display(std::cout);\n    harrz.display(std::cout);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"Harry 1234:\n 89.40\n 67.80\n 45.50\nHarry 1234:\n 89.40\n 67.80\n 45.50\n")),(0,a.kt)("h2",{id:"direct-call-copy-constructor"},"Direct Call Copy Constructor"),(0,a.kt)("p",null,"The alternative to sharing a private member function is a direct call from the copy constructor to the copy assignment operator (as in the chapter entitled ",(0,a.kt)("a",{parentName:"p",href:"/C-Encapsulation/classes-and-resources"},"Classes and Resources"),"). In a direct call, the assignment operator copies the base class part of the object and any call to the base class copy constructor is redundant."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"Student::Student(const Student& src) { // calls no-argument base constructor\n    grade = nullptr;\n    *this = src;\n}\n\nStudent& Student::operator=(const Student& src) {\n    if (this != &src) {\n        // Base class assignment\n        // 1 - functional expression\n        // Person::operator=(src);\n        // 2 - assignment expression\n        Person& person = *this; // only copies address\n        person = src;           // call base class operator\n        delete [] grade;\n        no = src.no;\n        ng = src.ng;\n        if (src.ng > 0) {\n            grade = new float[ng];\n            for (int i = 0; i < ng; i++)\n                grade[i] = src.grade[i];\n        }\n        else\n            grade = nullptr;\n    }\n    return *this;\n}\n")),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A derived class with a resource requires explicit definitions of its special member functions - constructors, copy assignment operator and destructor"),(0,a.kt)("li",{parentName:"ul"},"An explicitly defined derived class copy constructor without a call to the base class' copy constructor calls the base class' no-argument constructor"),(0,a.kt)("li",{parentName:"ul"},"The derived class' copy constructor executes the logic in the base class' copy constructor first"),(0,a.kt)("li",{parentName:"ul"},"An explicitly defined derived class copy assignment operator does NOT automatically call the base class assignment operator."),(0,a.kt)("li",{parentName:"ul"},"The derived class assignment operator executes the base class assignment operator entirely within the scope of the copy derived class assignment operator"),(0,a.kt)("li",{parentName:"ul"},"The destructor of a derived class automatically calls the destructor of the base class")))}u.isMDXComponent=!0}}]);