"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[864],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8922:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return l},default:function(){return c},frontMatter:function(){return r},metadata:function(){return o},toc:function(){return p}});var a=n(3117),i=(n(7294),n(3905));const r={id:"types-overloading-and-references",title:"Types, Overloading and References",sidebar_position:1,description:"TBD"},l="Types, Overloading and References",o={unversionedId:"B-Foundations/types-overloading-and-references",id:"B-Foundations/types-overloading-and-references",title:"Types, Overloading and References",description:"TBD",source:"@site/docs/B-Foundations/types-overloading-and-references.md",sourceDirName:"B-Foundations",slug:"/B-Foundations/types-overloading-and-references",permalink:"/B-Foundations/types-overloading-and-references",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/B-Foundations/types-overloading-and-references.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"types-overloading-and-references",title:"Types, Overloading and References",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Modular Programming",permalink:"/A-Introduction/modular-programming"},next:{title:"Dynamic Memory",permalink:"/B-Foundations/dynamic-memory"}},s={},p=[{value:"TYPES",id:"types",level:2},{value:"Fundamental Types",id:"fundamental-types",level:3},{value:"bool",id:"bool",level:4},{value:"bool to int",id:"bool-to-int",level:5},{value:"Compound Types",id:"compound-types",level:2},{value:"C++ example",id:"c-example",level:3},{value:"C example",id:"c-example-1",level:3},{value:"<code>auto</code> Keyword",id:"auto-keyword",level:2},{value:"DECLARATIONS AND DEFINITIONS",id:"declarations-and-definitions",level:2},{value:"Declarations",id:"declarations",level:3},{value:"Definitions",id:"definitions",level:3},{value:"One Definition Rule",id:"one-definition-rule",level:4},{value:"Declarations are not necessarily Definitions",id:"declarations-are-not-necessarily-definitions",level:4},{value:"Designing Away Multiple Definitions",id:"designing-away-multiple-definitions",level:3},{value:"Design Question",id:"design-question",level:3},{value:"Forward Declaration Solution",id:"forward-declaration-solution",level:4},{value:"Compact Solution",id:"compact-solution",level:4},{value:"Proper Header File Inclusion",id:"proper-header-file-inclusion",level:3},{value:"SCOPE",id:"scope",level:2},{value:"Going Out of Scope",id:"going-out-of-scope",level:3},{value:"Iterations",id:"iterations",level:4},{value:"Shadowing",id:"shadowing",level:3},{value:"FUNCTION OVERLOADING",id:"function-overloading",level:2},{value:"Function Signature",id:"function-signature",level:3},{value:"Prototypes",id:"prototypes",level:3},{value:"Prototypes Required",id:"prototypes-required",level:3},{value:"Default Parameter Values",id:"default-parameter-values",level:3},{value:"REFERENCES",id:"references",level:2},{value:"Comparison Examples",id:"comparison-examples",level:3},{value:"Swapping values by address",id:"swapping-values-by-address",level:4},{value:"Swapping values by reference",id:"swapping-values-by-reference",level:3},{value:"ARRAY OF POINTERS",id:"array-of-pointers",level:2},{value:"KEYWORDS",id:"keywords",level:2},{value:"SUMMARY",id:"summary",level:2}],d={toc:p};function c(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"types-overloading-and-references"},"Types, Overloading and References"),(0,i.kt)("p",null,"Part B - Foundations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Review types, declarations, definitions and scoping"),(0,i.kt)("li",{parentName:"ul"},"Introduce overloading and function signatures"),(0,i.kt)("li",{parentName:"ul"},"Introduce pass by reference and compare it to pass by address")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Correctness, simplicity, and clarity comes first" (Sutter, Alexandrescu, 2005)')),(0,i.kt)("p",null,"Object-oriented languages inherit from their non-object-oriented predecessors the concepts of variable declarations, data types, data structures, logic constructs, and modular programming. The C++ language inherits these features from the C language (see ",(0,i.kt)("a",{parentName:"p",href:"https://intro2c.sdds.ca/"},"IPC Notes")," for a detailed exposition)."),(0,i.kt)("p",null,"This chapter elaborates on these inherited concepts and introduces the new concepts of references and overloading, which the C++ language adds to its C core. This chapter concludes with a section on arrays of pointers, which is important later in the design of polymorphic objects."),(0,i.kt)("h2",{id:"types"},"TYPES"),(0,i.kt)("p",null,"The built-in types of the C++ language are called its fundamental types. The C++ language, like C, admits struct types constructed from these fundamental types and possibly other struct types. The C++ language standard refers to struct types as compound types. (The C language refers to struct types as derived types.)"),(0,i.kt)("h3",{id:"fundamental-types"},"Fundamental Types"),(0,i.kt)("p",null,"The fundamental types of C++ include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Integral Types (store data exactly in equivalent binary form and can be signed or unsigned)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"bool - not available in C"),(0,i.kt)("li",{parentName:"ul"},"char"),(0,i.kt)("li",{parentName:"ul"},"int - short, long, long long"))),(0,i.kt)("li",{parentName:"ul"},"Floating Point Types (store data to a specified precision - can store very small and very large values)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"float"),(0,i.kt)("li",{parentName:"ul"},"double - long double")))),(0,i.kt)("h4",{id:"bool"},"bool"),(0,i.kt)("p",null,"The bool type stores a logical value: true or false."),(0,i.kt)("p",null,"The ! operator reverses that value: !true is false and !false is true."),(0,i.kt)("p",null,"! is self-inverting on bool types, but not self-inverting on other types."),(0,i.kt)("h5",{id:"bool-to-int"},"bool to int"),(0,i.kt)("p",null,"Conversions from bool type to any integral type and vice versa require care. true promotes to an int of value 1, while false promotes to an int of value 0. Applying the ! operator to an int value other than 0 produces a value of 0, while applying the ! operator to an int value of 0 produces a value of 1. Note that the following code snippet displays 1 (not 4)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int x = 4;\ncout << !!x;\n\n")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"1\n")),(0,i.kt)("p",null,"Both C and C++ treat the integer value 0 as false and any other value as true."),(0,i.kt)("h2",{id:"compound-types"},"Compound Types"),(0,i.kt)("p",null,"A compound type is a type composed of other types. A struct is a compound type. An object-oriented class is also a compound type. To identify a compound type we use the keywords struct or class. We cover the syntax for classes in the following chapter."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Modular Example\n// Transaction.h\n\nstruct Transaction {\n    int acct;      // account number\n    char type;     // credit 'c' debit 'd'\n    double amount; // transaction amount\n};\n")),(0,i.kt)("p",null,"The C++ language requires the keyword identifying a compound type only in the declaration of that type. The language does not require the keyword struct or class in a function prototype or an object definition. Note the first code snippet below. Recall that the C language requires the keyword struct throughout the code as listed in the code snippet for C example below."),(0,i.kt)("h3",{id:"c-example"},"C++ example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"}," // Modular Example - C++\n // Transaction.h\n\n struct Transaction {\n     int acct;\n     char type;\n     double amount;\n };\n void enter(Transaction*);\n void display(const Transaction*);\n // ...\n\n int main() {\n     Transaction tr;\n     // ...\n }\n")),(0,i.kt)("h3",{id:"c-example-1"},"C example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-C"}," // Modular Example - C\n // Transaction.h\n\n struct Transaction {\n     int acct;\n     char type;\n     double amount;\n };\n void enter(struct Transaction*);\n void display(const struct Transaction*);\n // ...\n\n int main() {\n     struct Transaction tr;\n     // ...\n }\n")),(0,i.kt)("h2",{id:"auto-keyword"},(0,i.kt)("inlineCode",{parentName:"h2"},"auto")," Keyword"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," keyword was introduced in the C++11 standard. This keyword deduces the object's type directly from its initializer's type. We must provide the initializer in any ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," declaration."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"     auto x = 4;   // x is an int that is initialized to 4\n     auto y = 3.5; // y is a double that is initialized to 3.5\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"auto")," is quite useful: it simplifies our coding by using information that the compiler already has."),(0,i.kt)("h2",{id:"declarations-and-definitions"},"DECLARATIONS AND DEFINITIONS"),(0,i.kt)("p",null,"Modular programming can result in multiple definitions. To avoid conflicts or duplication, we need to design our header and implementation files accordingly. The C++ language distinguishes between declarations and definitions and stipulates the one-definition rule."),(0,i.kt)("h3",{id:"declarations"},"Declarations"),(0,i.kt)("p",null,"A declaration associates an entity with a type, telling the compiler how to interpret the entity's identifier. The entity may be a variable, an object or a function."),(0,i.kt)("p",null,"For example, the prototype"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int add(int, int);\n")),(0,i.kt)("p",null,"declares ",(0,i.kt)("inlineCode",{parentName:"p"},"add()")," to be a function that receives two ints and returns an int. This declaration does not specify what the function does; it does not specify the function's meaning."),(0,i.kt)("p",null,"For example, the ",(0,i.kt)("em",{parentName:"p"},"forward declaration")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Transaction;\n")),(0,i.kt)("p",null,"declares ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction")," to be of structure type. A forward declaration is like a function prototype: it tells the compiler how to interpret the entity's identifier. It tells the compiler that the entity is a valid type, but does not specify the entity's meaning."),(0,i.kt)("p",null,"Although a declaration does not necessarily specify meaning, it may specify it. Specifying a meaning is an optional part of any declaration."),(0,i.kt)("h3",{id:"definitions"},"Definitions"),(0,i.kt)("p",null,"A definition is a declaration that associates a meaning with an identifier."),(0,i.kt)("p",null,"For example, the following definitions attach meanings to ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction")," and to ",(0,i.kt)("inlineCode",{parentName:"p"},"display()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Transaction {\n    int acct;      // account number\n    char type;     // credit 'c' debit 'd'\n    double amount; // transaction amount\n };\n\n\n\nvoid display(const Transaction* tr) { // definition of display\n    cout << \"Account \" << tr->acct << endl;\n    cout << (tr->type == 'd' ? \" Debit $\" : \" Credit $\") << endl;\n    cout << tr->amount << endl;\n }\n")),(0,i.kt)("p",null,"In C++, each definition is an executable statement. We may embed it amongst other executable statements."),(0,i.kt)("p",null,"For example, we may place a definition within an initializer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"for (int i = 0; i < n; i++)\n   //...\n")),(0,i.kt)("h4",{id:"one-definition-rule"},"One Definition Rule"),(0,i.kt)("p",null,"In the C++ language, a definition may only appear once within its scope. This is called the one-definition rule."),(0,i.kt)("p",null,"For example, we cannot define Transaction or display() more than once within the same code block or translation unit."),(0,i.kt)("h4",{id:"declarations-are-not-necessarily-definitions"},"Declarations are not necessarily Definitions"),(0,i.kt)("p",null,"Forward declarations and function prototypes are declarations that are not definitions. They associate an identifier with a type, but do not attach any meaning to that identifier. We may repeat such declarations several times within the same code block or translation unit."),(0,i.kt)("p",null,"Header files consist of declarations. When we include several header files in a single implementation file, multiple declarations may occur. If some of the declarations are also definitions, this may result in multiple definitions within the same translation unit. Any translation unit must not break the one-definition rule. We need to design our header files to respect this rule."),(0,i.kt)("h3",{id:"designing-away-multiple-definitions"},"Designing Away Multiple Definitions"),(0,i.kt)("p",null,"A definition that appears more than once within the same translation unit generates a compiler error. Two solutions are shown below."),(0,i.kt)("p",null,"The program listed below consists of three modules: main, Transaction and iostream."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"main_trans_iost",src:n(2094).Z,width:"373",height:"248"})),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," module's implementation file we have introduced a new function called ",(0,i.kt)("inlineCode",{parentName:"p"},"add()"),", which receives the address of a ",(0,i.kt)("inlineCode",{parentName:"p"},"double")," and the address of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction")," object. This function update the value stored in the first address:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// One Definition Rule\n// one_defintion_rule.cpp\n\n#include <iostream>\n#include "main.h"        // prototype for add()\n#include "Transaction.h" // prototypes for enter() and display()\nusing namespace std;\n\nint main() {\n    int i;\n    double balance = 0.0;\n    Transaction tr;\n\n    for (i = 0; i < NO_TRANSACTIONS; i++) {\n        enter(&tr);\n        display(&tr);\n        add(&balance, &tr);\n    }\n    cout << "Balance " << balance << endl;\n}\n\nvoid add(double* bal, const Transaction* tr) {\n    *bal += (tr->type == \'d\' ? -tr->amount : tr->amount);\n}\n')),(0,i.kt)("p",null,"The Transaction module's header file defines the Transaction type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Modular Example\n// Transaction.h\n\nstruct Transaction {\n    int acct;      // account number\n    char type;     // credit 'c' debit 'd'\n    double amount; // transaction amount\n};\n\nvoid enter(Transaction* tr);\nvoid display(const Transaction* tr);\n")),(0,i.kt)("h3",{id:"design-question"},"Design Question"),(0,i.kt)("p",null,"Into which header file should we insert the prototype for this ",(0,i.kt)("inlineCode",{parentName:"p"},"add()")," function?"),(0,i.kt)("p",null,"If we insert the prototype into the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," module's header file, ",(0,i.kt)("inlineCode",{parentName:"p"},"main.cpp")," will not compile:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// main.h\n\n#define NO_TRANSACTIONS 3\n\nvoid add(double*, const Transaction*);\n")),(0,i.kt)("p",null,"The compiler will report ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction*")," as undeclared. Note that the compiler analyzes code sequentially and does not yet know what ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction")," is when it encounters the prototype for ",(0,i.kt)("inlineCode",{parentName:"p"},"add()"),"."),(0,i.kt)("p",null,"If we insert ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction.h")," into this header file (",(0,i.kt)("inlineCode",{parentName:"p"},"main.h"),"), we resolve this issue but break the one-definition rule in ",(0,i.kt)("inlineCode",{parentName:"p"},"main.cpp"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// main.h\n\n#define NO_TRANSACTIONS 3\n#include "Transaction.h"  // BREAKS THE ONE-DEFINITION RULE!\n\nvoid add(double*, const Transaction*);\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"main.cpp")," translation unit would contain TWO definitions of ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Conflict",src:n(7130).Z,width:"371",height:"246"})),(0,i.kt)("p",null,"Possible designs are possible include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Forward Declaration Solution - insert the prototype into main.h"),(0,i.kt)("li",{parentName:"ul"},"Compact Solution - insert the prototype into Transaction.h")),(0,i.kt)("h4",{id:"forward-declaration-solution"},"Forward Declaration Solution"),(0,i.kt)("p",null,"Inserting the prototype into ",(0,i.kt)("inlineCode",{parentName:"p"},"main.h")," along with a forward declaration of ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction")," informs the compiler that this identifier in the prototype is a valid type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// main.h\n\n#define NO_TRANSACTIONS 3\n\nstruct Transaction; // forward declaration\nvoid add(double*, const Transaction*);\n")),(0,i.kt)("p",null,"This design provides the compiler with just enough information to accept the identifer, without exposing the type details."),(0,i.kt)("h4",{id:"compact-solution"},"Compact Solution"),(0,i.kt)("p",null,"Inserting the prototype into the ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction.h")," header file is a more compact solution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Modular Example\n// Transaction.h\n\nstruct Transaction {\n    int acct;      // account number\n    char type;     // credit 'c' debit 'd'\n    double amount; // transaction amount\n};\n\nvoid enter(Transaction* tr);\nvoid display(const Transaction* tr);\nvoid add(double*, const Transaction*);\n")),(0,i.kt)("p",null,"This design localizes all declarations related to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction")," type within the same header file. We call functions that support a compound type the helper functions for that type."),(0,i.kt)("h3",{id:"proper-header-file-inclusion"},"Proper Header File Inclusion"),(0,i.kt)("p",null,"To avoid contaminating system header files, we include header files in the following order:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"#include < ... >")," - system header files"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'#include " ... "')," - other system header files"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'#include " ... "')," - your own header files")),(0,i.kt)("p",null,"We insert namespace declarations and directives after all header file inclusions."),(0,i.kt)("h2",{id:"scope"},"SCOPE"),(0,i.kt)("p",null,"The scope of a declaration is the portion of a program over which that declaration is visible. Scopes include"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"global scope - visible to the entire program"),(0,i.kt)("li",{parentName:"ul"},"file scope - visible to the source code within the file"),(0,i.kt)("li",{parentName:"ul"},"function scope - visible to the source code within the function"),(0,i.kt)("li",{parentName:"ul"},"class scope - visible to the member functions of the class"),(0,i.kt)("li",{parentName:"ul"},"block scope - visible to the code block")),(0,i.kt)("p",null,"The scope of a non-global declaration begins at the declaration and ends at the closing brace for that declaration. A non-global declaration is called a local declaration. We say that an identifier that has been locally declared is a local variable or object."),(0,i.kt)("h3",{id:"going-out-of-scope"},"Going Out of Scope"),(0,i.kt)("p",null,"Once a declaration is out of its scope, the program has lost access to the declared variable or object. Identifying the precise point at which a variable's or object's declaration goes out of scope is important in memory management."),(0,i.kt)("h4",{id:"iterations"},"Iterations"),(0,i.kt)("p",null,"In the following code snippet, the counter i, declared within the for statement, goes out of scope immediately after the closing brace:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'for (int i = 0; i < 4; i++) {\n    cout << "The value of i is " << i << endl;\n} // i goes out of scope here\n')),(0,i.kt)("p",null,"We cannot refer to i after the closing brace."),(0,i.kt)("p",null,"A variable or object declared within a block goes out of scope immediately before the block's closing brace."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},' for (int i = 0; i < 3; i++) {\n     int j = 2 * i;\n     cout << "The value of j is " << j << endl;\n } // j goes out of scope here\n')),(0,i.kt)("p",null,"The scope of j extends from its definition to just before the end of the current iteration. j goes out of scope with each iteration. The scope of i extends across the complete set of iterations."),(0,i.kt)("h3",{id:"shadowing"},"Shadowing"),(0,i.kt)("p",null,"An identifier declared with an inner scope can shadow an identifier declared with a broader scope, making the latter temporarily inaccessible. For example, in the following program the second declaration shadows the first declaration of i:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// scope.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int i = 6;\n    cout << i << endl;\n    for (int j = 0; j < 3; j++) {\n        int i = j * j;\n        cout << i << endl;\n    }\n    cout << i << endl;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"6\n0\n1\n4\n\n6\n")),(0,i.kt)("h2",{id:"function-overloading"},"FUNCTION OVERLOADING"),(0,i.kt)("p",null,"In object-oriented languages functions may have multiple meanings. Functions with multiple meanings are called overloaded functions. C++ refers to functions first and foremost by their identifier and distinguishes different meanings by differing parameter lists. For each identifier and parameter list combination, we implement a separate function definition. C++ compilers determine the definition to select by matching the argument types in the function call to the parameters types in the definition."),(0,i.kt)("h3",{id:"function-signature"},"Function Signature"),(0,i.kt)("p",null,"A function's signature identifies an overloaded function uniquely. Its signature consists of"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the function identifier"),(0,i.kt)("li",{parentName:"ul"},"the parameter types (ignoring const qualifiers or address of operators as described in references below)"),(0,i.kt)("li",{parentName:"ul"},"the order of the parameter types")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"}," type identifier ( type identifier [, ... , type identifier] )\n")),(0,i.kt)("p",null,"The square brackets enclose optional information. The return type and the parameter identifiers are not part of a function's signature."),(0,i.kt)("p",null,"C++ compilers preserve identifier uniqueness by renaming each overloaded function using a combination of its identifier, its parameter types and the order of its parameter types. We refer to this renaming as name mangling."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("p",null,"Consider the following example of an overloaded function. To display data on the standard output device, we can define a display() function with different meanings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Overloaded Functions\n// overload.cpp\n#include <iostream>\nusing namespace std;\n\n// prototypes\nvoid display(int x);\nvoid display(const int* x, int n);\n\nint main() {\n    auto x = 20;\n    int a[] = {10, 20, 30, 40};\n    display(x);\n    display(a, 4);\n}\n\n// function definitions\n//\nvoid display(int x) {\n    cout << x << endl;\n}\n\nvoid display(const int* x, int n) {\n    for (int i = 0; i < n; i++)\n        cout << x[i] << ' ';\n    cout << endl;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"}," 20\n 10 20 30 40\n")),(0,i.kt)("p",null,"C++ compilers generate two one definition of display() for each set of parameters. The linker binds each function call to the appropriate definition based on the argument types in the function call."),(0,i.kt)("h3",{id:"prototypes"},"Prototypes"),(0,i.kt)("p",null,"A function prototype completes the function's signature by specifying the return type. However, the parameter identifiers are also optional in the prototype. The prototype provides sufficient information to validate a function call."),(0,i.kt)("p",null,"A prototype without parameter types identifies an empty parameter list. The keyword void, which the C language uses to identify no parameters is redundant in C++. We omit this keyword in C++."),(0,i.kt)("h3",{id:"prototypes-required"},"Prototypes Required"),(0,i.kt)("p",null,"A programming language may require a function declaration before any function call for type safety. The declaration may be either a prototype or the function definition itself. The compiler uses the declaration to check the argument types in the call against the parameter types in the prototype or definition. The type safety features of C++ require a preceding declaration."),(0,i.kt)("p",null,"For example, the following program will generate a compiler error (note that the absence of any printf declaration):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'int main() {\n    printf("Hello C++\\n");\n}\n')),(0,i.kt)("p",null,"To meet type safety requirements, we include the prototype:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},' #include <cstdio> // the prototype is in this header file\n using namespace std;\n\n int main() {\n     printf("Hello C++\\n");\n }\n')),(0,i.kt)("h3",{id:"default-parameter-values"},"Default Parameter Values"),(0,i.kt)("p",null,"We may include default values for some or all of a function's parameters in the first declaration of that function. The parameters with default values must be the rightmost parameters in the function signature."),(0,i.kt)("p",null,"Declarations with default parameter values take the following form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"}," type identifier(type[, ...], type = value);\n")),(0,i.kt)("p",null,"The assignment operator followed by a value identifies the default value for each parameter."),(0,i.kt)("p",null,"Specifying default values for function parameters reduces the need for multiple function definitions if the function logic is identical in every respect except for the values received by the parameters."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Default Parameter Values\n// default.cpp\n\n#include <iostream>\nusing namespace std;\n\nvoid display(int, int = 5, int = 0);\n\nint main() {\n\n    display(6, 7, 8);\n    display(6);\n    display(3, 4);\n}\n\nvoid display(int a, int b, int c) {\n    cout << a << ", " << b << ", " << c << endl;\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"}," 6, 7, 8\n 6, 5, 0\n 3, 4, 0\n")),(0,i.kt)("p",null,"Each call to ",(0,i.kt)("inlineCode",{parentName:"p"},"display()")," must include enough arguments to initialize the parameters that don't have default values. In this example, each call must include at least one argument. An argument passed to a parameter that has a default value overrides the default value."),(0,i.kt)("h2",{id:"references"},"REFERENCES"),(0,i.kt)("p",null,"A reference is an alias for a variable or object. Object-oriented languages rely on referencing. A reference in a function call passes the variable or object rather than a copy. In other words, a reference is an alternative to the pass by address mechanism available in the C language. Pass-by-reference code is notably more readable than pass-by-address code. To enable referencing, the C++ rules on function declarations are stricter than those of the C language."),(0,i.kt)("p",null,"The declaration of a function parameter that is received as a reference to the corresponding argument in the function call takes the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"}," type identifier(type& identifier, ... )\n")),(0,i.kt)("p",null,"The & identifies the parameter as an alias for, rather than a copy of, the corresponding argument. The identifier is the alias for the argument within the function definition. Any change to the value of a parameter received by reference changes the value of the corresponding argument in the function call."),(0,i.kt)("h3",{id:"comparison-examples"},"Comparison Examples"),(0,i.kt)("p",null,"Consider a function that swaps the values stored in two different memory locations. The programs listed below compare pass-by-address and pass-by-reference solutions. The program on the left passes by address using pointers. The program on the right passes by reference:"),(0,i.kt)("h4",{id:"swapping-values-by-address"},"Swapping values by address"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Swapping values by address\n// swap1.cpp\n\n#include <iostream>\nusing namespace std;\nvoid swap ( char *a, char *b );\n\nint main ( ) {\n    char left;\n    char right;\n\n    cout << "left  is ";\n    cin  >> left;\n    cout << "right is ";\n    cin  >> right;\n\n    swap(&left, &right);\n\n    cout << "After swap:"\n        "\\nleft  is " <<\n        left <<\n        "\\nright is " <<\n        right <<\n        endl;\n}\n\nvoid swap ( char *a, char *b ) {\n    char c;\n\n    c = *a;\n    *a = *b;\n    *b = c;\n}\n')),(0,i.kt)("h3",{id:"swapping-values-by-reference"},"Swapping values by reference"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Swapping values by reference\n// swap2.cpp\n\n#include <iostream>\nusing namespace std;\nvoid swap ( char &a, char &b );\n\nint main ( ) {\n    char left;\n    char right;\n\n    cout << "left  is ";\n    cin  >> left;\n    cout << "right is ";\n    cin  >> right;\n\n    swap(left, right);\n\n    cout << "After swap:"\n        "\\nleft  is " <<\n        left <<\n        "\\nright is " <<\n        right <<\n        endl;\n}\n\nvoid swap ( char &a, char &b ) {\n    char c;\n\n    c = a;\n    a = b;\n    b = c;\n}\n')),(0,i.kt)("p",null,"Clearly, reference syntax is simpler. To pass an object by reference, we attach the address of operator to the parameter type. This operator instructs the compiler to pass by reference. The corresponding arguments in the function call and the object names within the function definition are not prefixed by the dereferencing operator required in passing by address."),(0,i.kt)("p",null,"Technically, the compiler converts each reference to a pointer with an unmodifiable address."),(0,i.kt)("h2",{id:"array-of-pointers"},"ARRAY OF POINTERS"),(0,i.kt)("p",null,"Arrays of pointers are data structures like arrays of values. Arrays of pointers contain addresses rather than values. We refer to the object stored at a particular address by dereferencing that address. Arrays of pointers play an important role in implementing polymorphism in the C++ language."),(0,i.kt)("p",null,"An array of pointers provides an efficient mechanism for processing the set. With the objects' addresses collected in a contiguous array, we can refer to each object indirectly through the pointers in the array and process the data by iterating on its elements."),(0,i.kt)("p",null,"In preparation for a detailed study of polymorphic objects later in this course, consider the following preliminary example:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},' // Array of Pointers\n // array_pointers.cpp\n\n #include <iostream>\n using namespace std;\n\n const int N_CHARS = 31;\n\n struct Student {\n     int no;\n     double grade;\n     char name[N_CHARS];\n };\n\n int main() {\n     const int NO_STUDENTS = 3;\n     Student john = {1234, 67.8, "john"};\n     Student jane = {1235, 89.5, "jane"};\n     Student dave = {1236, 78.4, "dave"};\n\n     Student* pStudent[NO_STUDENTS]; // array of pointers\n     pStudent[0] = &john;\n     pStudent[1] = &jane;\n     pStudent[2] = &dave;\n\n     for (int i = 0; i < NO_STUDENTS; i++) {\n         cout << pStudent[i]->no << endl;\n         cout << pStudent[i]->grade << endl;\n         cout << pStudent[i]->name << endl;\n         cout << endl;\n     }\n }\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"}," 1234\n 67.8\n john\n\n 1235\n 89.5\n jane\n\n 1236\n 78.4\n dave\n")),(0,i.kt)("p",null,"Here, while the objects are of the same type, the processing of their data is done indirectly through an array of pointers to that data."),(0,i.kt)("h2",{id:"keywords"},"KEYWORDS"),(0,i.kt)("p",null,"The 84 keywords of the C++11 standard are listed below. We cannot use any of these keywords as identifiers. Those in bold are also C keywords. The italicized keywords are alternative tokens for operators."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"alignas"),(0,i.kt)("td",{parentName:"tr",align:null},"alignof"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"and")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"and_eq")),(0,i.kt)("td",{parentName:"tr",align:null},"asm"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"auto")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"bitand"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"itor"),(0,i.kt)("td",{parentName:"tr",align:null},"bool"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"break")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"case")),(0,i.kt)("td",{parentName:"tr",align:null},"catch"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"char")),(0,i.kt)("td",{parentName:"tr",align:null},"char16_t")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"char32_t"),(0,i.kt)("td",{parentName:"tr",align:null},"class"),(0,i.kt)("td",{parentName:"tr",align:null},"compl"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"const")),(0,i.kt)("td",{parentName:"tr",align:null},"constexpr"),(0,i.kt)("td",{parentName:"tr",align:null},"const_cast"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"continue"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"decltype"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"default")),(0,i.kt)("td",{parentName:"tr",align:null},"delete"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"do")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"double")),(0,i.kt)("td",{parentName:"tr",align:null},"dynamic_cast"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"else"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"enum")),(0,i.kt)("td",{parentName:"tr",align:null},"explicit"),(0,i.kt)("td",{parentName:"tr",align:null},"export"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"extern")),(0,i.kt)("td",{parentName:"tr",align:null},"false"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"float")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"for"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"friend"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"goto")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"if")),(0,i.kt)("td",{parentName:"tr",align:null},"inline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"int")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"long")),(0,i.kt)("td",{parentName:"tr",align:null},"mutable")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"namespace"),(0,i.kt)("td",{parentName:"tr",align:null},"new"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"not")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"not_eq")),(0,i.kt)("td",{parentName:"tr",align:null},"noexcept"),(0,i.kt)("td",{parentName:"tr",align:null},"nullptr"),(0,i.kt)("td",{parentName:"tr",align:null},"operator")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"or")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"or_eq")),(0,i.kt)("td",{parentName:"tr",align:null},"private"),(0,i.kt)("td",{parentName:"tr",align:null},"protected"),(0,i.kt)("td",{parentName:"tr",align:null},"public"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"register")),(0,i.kt)("td",{parentName:"tr",align:null},"reinterpret_cast")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"return")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"short")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"signed")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"sizeof")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"static")),(0,i.kt)("td",{parentName:"tr",align:null},"static_assert"),(0,i.kt)("td",{parentName:"tr",align:null},"static_cast")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"struct")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"switch")),(0,i.kt)("td",{parentName:"tr",align:null},"template"),(0,i.kt)("td",{parentName:"tr",align:null},"this"),(0,i.kt)("td",{parentName:"tr",align:null},"thread_local"),(0,i.kt)("td",{parentName:"tr",align:null},"throw"),(0,i.kt)("td",{parentName:"tr",align:null},"true")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"try"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"typedef")),(0,i.kt)("td",{parentName:"tr",align:null},"typeid"),(0,i.kt)("td",{parentName:"tr",align:null},"typename"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"union")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"unsigned")),(0,i.kt)("td",{parentName:"tr",align:null},"using")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"virtual"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"void")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"volatile")),(0,i.kt)("td",{parentName:"tr",align:null},"wchar_t"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"while")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"xor")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},"xor_eq"))))),(0,i.kt)("p",null,"C++ compilers will successfully compile any C program that does not use any of these keywords as identifiers provided that that program satisfies C++'s type safety requirements. We call such a C program a clean C program."),(0,i.kt)("h2",{id:"summary"},"SUMMARY"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a bool type can only hold a true value or a false value"),(0,i.kt)("li",{parentName:"ul"},"C++ requires the struct or class keyword only in the definition of the class itself"),(0,i.kt)("li",{parentName:"ul"},"a declaration associates an identifier with a type"),(0,i.kt)("li",{parentName:"ul"},"a definition attaches meaning to an identifier and is an executable statement"),(0,i.kt)("li",{parentName:"ul"},"a definition is a declaration, but a declaration is not necessarily a definition"),(0,i.kt)("li",{parentName:"ul"},"the scope of a declaration is that part of the program throughout which the declaration is visible"),(0,i.kt)("li",{parentName:"ul"},"we overload a function by changing its signature"),(0,i.kt)("li",{parentName:"ul"},"a function's signature consists of its identifier, its parameter types, and the order of its parameter types"),(0,i.kt)("li",{parentName:"ul"},"a C++ function prototype must include all of the parameter types and the return type"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"&")," operator on a parameter type instructs the compiler to pass by reference"),(0,i.kt)("li",{parentName:"ul"},"pass by reference syntax simplifies the pass by address syntax in most cases"),(0,i.kt)("li",{parentName:"ul"},"an array of pointers is a data structure that provides an efficient way for iterating through a set of objects based on their current type")))}c.isMDXComponent=!0},2094:function(e,t,n){t.Z=n.p+"assets/images/15-main_trans_iostr-8e50b3d78d4704c650c827be48470c05.png"},7130:function(e,t,n){t.Z=n.p+"assets/images/16-causeOfConflict-cd593091e5017529004cd4368e5c07ad.png"}}]);