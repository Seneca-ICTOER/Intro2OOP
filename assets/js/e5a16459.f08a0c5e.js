"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[781],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return h}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),d=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=d(e.components);return i.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(t),m=a,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return t?i.createElement(h,o(o({ref:n},p),{},{components:t})):i.createElement(h,o({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var d=2;d<r;d++)o[d]=t[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7641:function(e,n,t){t.r(n),t.d(n,{assets:function(){return s},contentTitle:function(){return o},default:function(){return c},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return d}});var i=t(3117),a=(t(7294),t(3905));const r={id:"relation-between-cpp-and-c",title:"Relation Between C++ and C",sidebar_position:4,description:"TBD"},o="Relation Between C++ And C",l={unversionedId:"Resources-Appendices/relation-between-cpp-and-c",id:"Resources-Appendices/relation-between-cpp-and-c",title:"Relation Between C++ and C",description:"TBD",source:"@site/docs/Resources-Appendices/relation-between-cpp-and-c.md",sourceDirName:"Resources-Appendices",slug:"/Resources-Appendices/relation-between-cpp-and-c",permalink:"/Resources-Appendices/relation-between-cpp-and-c",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/Resources-Appendices/relation-between-cpp-and-c.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"relation-between-cpp-and-c",title:"Relation Between C++ and C",sidebar_position:4,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Operator Precedence",permalink:"/Resources-Appendices/operator-precedence"}},s={},d=[{value:"Differences between C++ and C",id:"differences-between-c-and-c",level:2},{value:"Terminology",id:"terminology",level:3},{value:"Definition",id:"definition",level:4},{value:"Derived Type",id:"derived-type",level:4},{value:"Class Identification",id:"class-identification",level:4},{value:"Prototyping",id:"prototyping",level:4},{value:"An Empty Parameter List",id:"an-empty-parameter-list",level:4},{value:"Legacy Code",id:"legacy-code",level:2},{value:"<code>for</code> <code>int</code> scope",id:"for-int-scope",level:3},{value:"Libraries",id:"libraries",level:3},{value:"<code>iostream</code>",id:"iostream",level:3},{value:"C-Style Libraries",id:"c-style-libraries",level:3}],p={toc:d};function c(e){let{components:n,...r}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"relation-between-c-and-c"},"Relation Between C++ And C"),(0,a.kt)("p",null,"The evolution of C++ is documented in the ISO/IEC 14882 set of standards, informally known as C++98, C++11 and C++14, while the evolution of C is documented in the ISO/IEC 9899 set of standards, informally known as C89, C99 and C11. Standard C++ and Standard C are now considered siblings."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Evolution of C++",src:t(6171).Z,width:"1411",height:"292"})),(0,a.kt)("p",null,"The standards committees of C++ and C have cooperated to keep both as closely related as possible without jeopardizing their distinct objectives: proximity to the application domain (C++) and proximity to the metal (C). In general, C++ is more expressive than C."),(0,a.kt)("p",null,"This appendix describes the differences in terminology between C++ and C along with the legacy features that C++ inherited from C but have been removed or deprecated with the latest standards."),(0,a.kt)("h2",{id:"differences-between-c-and-c"},"Differences between C++ and C"),(0,a.kt)("h3",{id:"terminology"},"Terminology"),(0,a.kt)("h4",{id:"definition"},"Definition"),(0,a.kt)("p",null,"In C++, a definition identifies a declaration that attaches meaning to an identifier. A definition is ",(0,a.kt)("em",{parentName:"p"},"eventually")," used to allocate memory, but does not necessarily allocate it at declaration time."),(0,a.kt)("p",null,"In C, a definition allocates memory for an identifer, whether a variable, an object or program code. The term is used more conservatively."),(0,a.kt)("h4",{id:"derived-type"},"Derived Type"),(0,a.kt)("p",null,"In C++, a derived type is a compound type that is derived from another compound type through inheritance. A compound type is a structure or class that is composed of other types, which may be fundamental or compound or a combination of the two."),(0,a.kt)("p",null,"In C, a derived type is a structure. C does not support inheritance. A structure, like a class in C++, is composed of other types, which may be derived types or fundamental types or a combination of both."),(0,a.kt)("h4",{id:"class-identification"},"Class Identification"),(0,a.kt)("p",null,"In C++, we only include the keyword that identifies a class (",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"class"),") in the definition of the class itself and in a forward declaration. We may omit it in any subsequent object definition or parameter declaration."),(0,a.kt)("p",null,"C requires the keyword that identifies a derived type (",(0,a.kt)("inlineCode",{parentName:"p"},"struct"),") in each declaration of a derived type. These declarations include object definitions and parameter declarations."),(0,a.kt)("p",null,"For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// sufficient in C++\n\nStudent s;\nvoid display(const Student* s);\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"// required in C\n\nstruct Student s;\nvoid display(const struct Student* s);\n")),(0,a.kt)("h4",{id:"prototyping"},"Prototyping"),(0,a.kt)("p",null,"In C++, a function prototype must list all of its parameter types in their proper order. This constraint enables the language to support both overloading and references."),(0,a.kt)("p",null,"In C, listing the parameter types in a function prototype is optional. The code below compiles successfully under a C compiler. A C++ compiler requires the code further below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'// sufficient in C\n\n#include <stdio.h>\n\nvoid foo();\nint main () {\n    int a = 5;\n    foo(a);\n}\nvoid foo(int a) {\n    printf("a is %d\\n", a);\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// required in C++\n\n#include <iostream>\n\nvoid foo(int);\nint main () {\n    int a = 5;\n    foo(a);\n}\nvoid foo(int a) {\n    std::cout << "a is " << a << std::endl;\n}\n')),(0,a.kt)("h4",{id:"an-empty-parameter-list"},"An Empty Parameter List"),(0,a.kt)("p",null,"In C++, an empty parameter list identicates to the compiler that the function has no parameters."),(0,a.kt)("p",null,"In C, an empty parameter list has either of two interpretations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The function has no parameters"),(0,a.kt)("li",{parentName:"ul"},"The function has some parameters but the compiler should omit checking argument types against parameter types")),(0,a.kt)("p",null,"The recommended way to specify that a function has no parameters in C is to include the keyword ",(0,a.kt)("inlineCode",{parentName:"p"},"void")," between the parentheses in the function header."),(0,a.kt)("h2",{id:"legacy-code"},"Legacy Code"),(0,a.kt)("p",null,"Applications written for pre-standard C++ compilers may include code that requires upgrading to meet the stricter requirements of Standard C++. Common issues include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"for")," ",(0,a.kt)("inlineCode",{parentName:"li"},"int")," scope"),(0,a.kt)("li",{parentName:"ul"},"original libraries"),(0,a.kt)("li",{parentName:"ul"},"insufficient memory")),(0,a.kt)("p",null,"Some compilers can still create executable files from pre-standard C++ source code. A copy of the Borland Win 32 5.5 compiler can be downloaded ",(0,a.kt)("a",{parentName:"p",href:"https://scs.senecac.on.ca/~chris.szalwinski/resources/borland.html"},"here"),". Many compilers have removed the deprecated pre-standard facilities and only conform to those features (or a majority of them) specified in C++11."),(0,a.kt)("h3",{id:"for-int-scope"},(0,a.kt)("inlineCode",{parentName:"h3"},"for")," ",(0,a.kt)("inlineCode",{parentName:"h3"},"int")," scope"),(0,a.kt)("p",null,"In pre-standard C++, the scope of a variable defined in the ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," clause extends beyond the closing brace of the block that encloses the iteration. In C++11, the scope of such a variable extends only to the end of the iteration block."),(0,a.kt)("p",null,"For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// valid in pre-standard C++\n\nfor (int i = 0; i < 10; i++) {\n    x[i] = i * i;\n    y[i] = i;\n}\ni = 0; // i is still in scope\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// invalid in standard C++\n\nfor (int i = 0; i < 10; i++) {\n    x[i] = i * i;\n    y[i] = i;\n}\ni = 0; // ERROR i is out of scope\n")),(0,a.kt)("p",null,"A C++11 compliant compiler reports this error."),(0,a.kt)("h3",{id:"libraries"},"Libraries"),(0,a.kt)("p",null,"The pre-standard C++ libraries are available with the Borland Win 32 5.5 compiler. They are currently deprecated in the ",(0,a.kt)("inlineCode",{parentName:"p"},"g++")," GNU compiler. They are not available in the Visual Studio 2012 compiler."),(0,a.kt)("h3",{id:"iostream"},(0,a.kt)("inlineCode",{parentName:"h3"},"iostream")),(0,a.kt)("p",null,"The pre-standard version of the ",(0,a.kt)("inlineCode",{parentName:"p"},"iostream")," library is a simple wrapper on the C functions prototyped in the ",(0,a.kt)("inlineCode",{parentName:"p"},"stdio.h")," header file. This pre-standard version defined the ",(0,a.kt)("inlineCode",{parentName:"p"},"cin"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"cout"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"cerr")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"clog")," objects as global objects rather than objects in the ",(0,a.kt)("inlineCode",{parentName:"p"},"std")," namespace. The header file for this pre-standard version is ",(0,a.kt)("inlineCode",{parentName:"p"},"iostream.h"),"."),(0,a.kt)("p",null,"The standard version of the ",(0,a.kt)("inlineCode",{parentName:"p"},"iostream")," library was fully redesigned with C++98 and notably larger than its C-like predecessor. All of the functions in the newer library are declared and defined in the ",(0,a.kt)("inlineCode",{parentName:"p"},"std")," namespace."),(0,a.kt)("p",null,"Compare the coding for the two versions listed below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Pre-Standard C++\n// pre_std_io.cpp\n\n#include <iostream.h>\n\nint main() {\n    cout << "Hello World!\\n";\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Standard C++\n// std_io.cpp\n\n#include <iostream>\n\nint main() {\n    std::cout << "Hello World!\\n";\n}\n')),(0,a.kt)("h3",{id:"c-style-libraries"},"C-Style Libraries"),(0,a.kt)("p",null,"In pre-standard C++, the header files for the C libraries have ",(0,a.kt)("inlineCode",{parentName:"p"},".h")," extensions as in the C language. Pre-standard library classes, objects and prototypes are all defined in the global namespace."),(0,a.kt)("p",null,"C++98 introduced unique header file names to distinguish the standard libraries from their pre-standard predecessors. The standard header file names begin with the character ",(0,a.kt)("inlineCode",{parentName:"p"},"c"),", are followed by the C-style name and do not include the ",(0,a.kt)("inlineCode",{parentName:"p"},".h")," extension. The standard files declare the prototypes and objects in the ",(0,a.kt)("inlineCode",{parentName:"p"},"std")," namespace. This renaming convention applied wherever the standard introduced minor changes."),(0,a.kt)("p",null,"C++98 renamed ",(0,a.kt)("inlineCode",{parentName:"p"},"stdio.h")," as ",(0,a.kt)("inlineCode",{parentName:"p"},"cstdio"),". The code for ",(0,a.kt)("inlineCode",{parentName:"p"},"cstdio")," is about the same size as the code for ",(0,a.kt)("inlineCode",{parentName:"p"},"stdio.h"),". Similarly, ",(0,a.kt)("inlineCode",{parentName:"p"},"<cstring>")," is the C++ version of the C header file ",(0,a.kt)("inlineCode",{parentName:"p"},"<string.h>"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"<cmath>")," is the C++ version of ",(0,a.kt)("inlineCode",{parentName:"p"},"<math.h>"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"<cstdlib>")," is the C++ version of ",(0,a.kt)("inlineCode",{parentName:"p"},"<stdlib.h>")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"<cctype>")," is the C++ version of ",(0,a.kt)("inlineCode",{parentName:"p"},"<ctype.h>"),". With the standard C++ libraries, we identify the namespace:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// sufficient in pre-standard C++\n\n#include <string.h>\n\nchar name[] = "Harry";\nint len = strlen(name);\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// necessary in Standard C++\n\n#include <cstring>\n\nchar name[] = "Harry";\nint len = std::strlen(name);\n')))}c.isMDXComponent=!0},6171:function(e,n,t){n.Z=t.p+"assets/images/evolution-71c30aa4e4e7514c9d4655543656203e.png"}}]);