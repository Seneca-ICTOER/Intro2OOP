"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[81],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return f}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,f=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(f,o(o({ref:t},d),{},{components:n})):a.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6305:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return c},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return p}});var a=n(3117),i=(n(7294),n(3905));const r={id:"input-and-output-refinements",title:"Input and Output Refinements",sidebar_position:1,description:"TBD"},o="Input and Output Refinements",l={unversionedId:"F-Refinements/input-and-output-refinements",id:"F-Refinements/input-and-output-refinements",title:"Input and Output Refinements",description:"TBD",source:"@site/docs/F-Refinements/input-and-output-refinements.md",sourceDirName:"F-Refinements",slug:"/F-Refinements/input-and-output-refinements",permalink:"/F-Refinements/input-and-output-refinements",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/Intro2OOP/tree/main/docs/F-Refinements/input-and-output-refinements.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"input-and-output-refinements",title:"Input and Output Refinements",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Overview of Polymorphism",permalink:"/E-Polymorphism/overview-of-polymorphism"},next:{title:"Derived Classes and Resources",permalink:"/F-Refinements/derived-classes-and-resources"}},s={},p=[{value:"Stream and Stream Objects",id:"stream-and-stream-objects",level:2},{value:"Input Objects",id:"input-objects",level:2},{value:"Extraction",id:"extraction",level:3},{value:"Whitespace",id:"whitespace",level:3},{value:"Cascading",id:"cascading",level:3},{value:"Overflow",id:"overflow",level:3},{value:"Member functions",id:"member-functions",level:3},{value:"<code>ignore()</code>",id:"ignore",level:4},{value:"<code>get()</code>",id:"get",level:4},{value:"<code>getline()</code>",id:"getline",level:4},{value:"Output Objects",id:"output-objects",level:2},{value:"Inserting Data",id:"inserting-data",level:3},{value:"Cascading",id:"cascading-1",level:3},{value:"Member Functions",id:"member-functions-1",level:3},{value:"<code>width()</code>",id:"width",level:4},{value:"<code>fill()</code>",id:"fill",level:4},{value:"<code>setf()</code>, <code>unsetf()</code> - Format control",id:"setf-unsetf---format-control",level:4},{value:"<code>setf()</code>, <code>unsetf()</code> - Alignment",id:"setf-unsetf---alignment",level:4},{value:"<code>precision()</code>",id:"precision",level:4},{value:"Manipulators (Optional)",id:"manipulators-optional",level:2},{value:"Input Manipulators",id:"input-manipulators",level:3},{value:"Output Manipulators",id:"output-manipulators",level:3},{value:"Reference Example (Optional)",id:"reference-example-optional",level:3},{value:"State",id:"state",level:2},{value:"Robust Validation",id:"robust-validation",level:2},{value:"<code>getPosInt()</code>",id:"getposint",level:3},{value:"File Stream Classes (Optional)",id:"file-stream-classes-optional",level:2},{value:"Extraction and Insertion Operator Overloads",id:"extraction-and-insertion-operator-overloads",level:3},{value:"Fundamental Types",id:"fundamental-types",level:4},{value:"Custom Types",id:"custom-types",level:4},{value:"Nice to Know (Optional)",id:"nice-to-know-optional",level:3},{value:"Open-Mode Flags",id:"open-mode-flags",level:4},{value:"The Defaults",id:"the-defaults",level:4},{value:"The Logical Negation Operator",id:"the-logical-negation-operator",level:4},{value:"Rewinding a Connection",id:"rewinding-a-connection",level:4},{value:"istream, fstream",id:"istream-fstream",level:5},{value:"ostream, fstream",id:"ostream-fstream",level:5},{value:"Premature Closing",id:"premature-closing",level:4},{value:"Writing to and Reading from the Same File",id:"writing-to-and-reading-from-the-same-file",level:4},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}],d={toc:p};function c(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"input-and-output-refinements"},"Input and Output Refinements"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use stream objects to interact with users and access persistent data"),(0,i.kt)("li",{parentName:"ul"},"Introduce manipulators to format data for input and output objects"),(0,i.kt)("li",{parentName:"ul"},"Describe the member functions that manage the state of streaming objects")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'"Designing and implementing a general input/output facility for a programming language is notoriously difficult. ... Nobody has come up with a solution that pleases everyone" ',(0,i.kt)("strong",{parentName:"p"},"Stroustrup, 1997."))),(0,i.kt)("p",null,"The chapter entitled ",(0,i.kt)("a",{parentName:"p",href:"/B-Foundations/member-functions-and-privacy"},"Member Functions and Privacy")," covered the public member functions that format data passing through the standard library's ",(0,i.kt)("inlineCode",{parentName:"p"},"iostream")," objects. The chapter entitled ",(0,i.kt)("a",{parentName:"p",href:"/C-Encapsulation/input-and-output-operators"},"Input and Output Operators")," covered the design of custom input and output operators and introduced the standard library's ",(0,i.kt)("inlineCode",{parentName:"p"},"fstream")," classes for processing file data."),(0,i.kt)("p",null,"This chapter describes in more detail the input and output objects along with their public member functions reviews the material covered in those preceding chapters. This chapter introduces manipulators as a simplifying alternative to member function calls on input and output objects."),(0,i.kt)("h2",{id:"stream-and-stream-objects"},"Stream and Stream Objects"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"stream")," is a sequence of items without limitation. More specifically, in C++ a stream is a sequence of bytes. An executing application accepts data in one stream and outputs data in another stream. The number of bytes in a stream can be indeterminate. Input objects store data from an input stream in the application's memory. Output objects copy data from the application's memory into an output stream. Both input and output objects operate in FIFO (First In First Out) order."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"streams",src:n(2824).Z,width:"544",height:"85"})),(0,i.kt)("p",null,"The standard input and output objects of the ",(0,i.kt)("inlineCode",{parentName:"p"},"iostream")," library represent the standard peripheral devices, such as the keyboard and display."),(0,i.kt)("p",null,"An input object converts a sequence of bytes from its attached input stream into values of specified type, which are stored in system memory. An output object converts values of specified type, which have been stored in system memory, into a sequence of bytes in its associated output stream. Both types of objects use the data type associated with the region of memory to make the appropriate conversions from or to the sequence of bytes in each stream."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"memory_io",src:n(6735).Z,width:"462",height:"75"})),(0,i.kt)("p",null,"The data in a stream, unlike the data stored in a region of memory, is not associated with any particular type. The notion of type is programming language specific."),(0,i.kt)("h2",{id:"input-objects"},"Input Objects"),(0,i.kt)("p",null,"An input object is an instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"istream")," class. The ",(0,i.kt)("inlineCode",{parentName:"p"},"istream")," class defines the structure of an input device. The object extracts data from the input stream and stores it in system memory, converting each sequence of bytes in the input stream into an equivalent value in system memory based on the specified variable's type."),(0,i.kt)("h3",{id:"extraction"},"Extraction"),(0,i.kt)("p",null,"The expression for extracting bytes from an input stream takes the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"inputObject >> identifier\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"inputObject")," is the name of the input object, ",(0,i.kt)("inlineCode",{parentName:"p"},">>")," is the extraction operator and ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," is the name of the destination variable."),(0,i.kt)("p",null,"The standard ",(0,i.kt)("inlineCode",{parentName:"p"},"iostream")," library defines one input object for buffered input: ",(0,i.kt)("inlineCode",{parentName:"p"},"cin"),"."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'int i;\nchar c;\ndouble x;\nchar s[8];\ncout << "Enter an integer,\\n"\n        "a character,\\n"\n        "a floating-point number and\\n"\n        "a string : " << flush;\ncin >> i;\ncin >> c;\ncin >> x;\ncin >> s;  // possible overflow\ncout << "Entered " << i << \' \'\n     << c << \' \' << x << \' \' << s << endl;\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Enter an integer,\na character,\na floating-point and\na string : 6 - 9.75 Harry\n\nEntered 6 - 9.75 Harry\n")),(0,i.kt)("p",null,"Each expression that takes an ",(0,i.kt)("inlineCode",{parentName:"p"},"istream")," object as its left operand converts the next sequence of bytes in the attached input stream into a value stored in the type of the expression's right operand."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"cin")," object skips leading whitespace with numeric, string and character types (in the same way that ",(0,i.kt)("inlineCode",{parentName:"p"},'scanf("%d"...)'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'scanf("%lf"...)'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'scanf("%s"...)')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'scanf(" %c"...)')," skip whitespace in C)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Leading Whitespace\n// leading.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char str[11];\n\n    cout << "Enter a string : " << endl;\n    cin >> str;\n    cout << "|" << str << "|" << endl;\n}\n')),(0,i.kt)("p",null,"Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," denotes space."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Enter a string :\n_abc\n|abc|\n")),(0,i.kt)("h3",{id:"whitespace"},"Whitespace"),(0,i.kt)("p",null,"The input object treats whitespace in its input stream as a delimiter for numeric and string data types. In converting input bytes into a C-style null-terminated string, the input object adds the null byte after the last non-whitespace character stored in memory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Trailing Whitespace\n// trailing.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char str[11];\n\n    cout << "Enter a string : " << endl;\n    cin >> str;\n    cout << "|" << str << "|" << endl;\n}\n')),(0,i.kt)("p",null,"Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," denotes space."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Enter a string :\n_abc_\n|abc|\n")),(0,i.kt)("h3",{id:"cascading"},"Cascading"),(0,i.kt)("p",null,"We can compress a sequence of extraction operations into a single compound expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'int i;\nchar c;\ndouble x;\nchar s[8];\ncout << "Enter an integer,\\n"\n        "a character,\\n"\n        "a floating-point number and\\n"\n        "a string : " << flush;\ncin >> i >> c >> x >> s;\ncout << "Entered " << i << \' \'\n    << c << \' \' << x << \' \' << s << endl;\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Enter an integer,\na character,\na floating-point and\na string : 6 - 9.75 Harry\n\nEntered 6 - 9.75 Harry\n")),(0,i.kt)("p",null,"We call such repeated use of the extraction operator ",(0,i.kt)("em",{parentName:"p"},"cascading"),"."),(0,i.kt)("p",null,"Note that reading a sequence of bytes in this manner is discouraged (see below)."),(0,i.kt)("h3",{id:"overflow"},"Overflow"),(0,i.kt)("p",null,"In the above two examples, overflow may occur while filling ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),". The extraction operator ",(0,i.kt)("inlineCode",{parentName:"p"},">>")," does not restrict the number of bytes accepted. If more than 7 bytes are in the input stream the data stored for the string may corrupt other data that has been stored in memory as shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Overflow\n// overflow.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int i;\n    char c;\n    double x;\n    char s[8];\n    cout << "Enter an integer,\\n"\n        "a character,\\n"\n        "a floating-point number and\\n"\n        "a string : \\n";\n    cin >> i >> c >> x >> s;\n    cout << "Entered " << endl;\n    cout << i << \' \'\n        << c << \' \' << x << \' \' << s << endl;\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Enter an integer,\na character,\na floating-point and\na string :\n6 - 9.75 Constantinople\n\nEntered\n6 - 2.04952 Constantinople\n")),(0,i.kt)("p",null,"The corruption varies from platform to platform."),(0,i.kt)("h3",{id:"member-functions"},"Member functions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"istream")," type supports the following member functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignore(...)"),": Ignores/discards character(s) from the input buffer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get(...)"),": Extracts a character or a string from the input buffer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getline(...)"),": Extracts a line of characters from the input buffer")),(0,i.kt)("h4",{id:"ignore"},(0,i.kt)("inlineCode",{parentName:"h4"},"ignore()")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore()")," member function extracts bytes from the input buffer and discards them without skipping whitespace. The ",(0,i.kt)("inlineCode",{parentName:"p"},"iostream")," hierarchy defines two overloaded versions of ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"cin.ignore();\ncin.ignore(2000, '\\n');\n")),(0,i.kt)("p",null,"The no-argument version discards a single byte. The two-argument version removes and discards up to the number of bytes specified by the first argument or up to the specified delimiting character, whichever occurs first and discards the delimiting character. The default delimiter is the end-of-file character (not the newline character)."),(0,i.kt)("h4",{id:"get"},(0,i.kt)("inlineCode",{parentName:"h4"},"get()")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," member function extracts either a single character or a string from the input buffer. Three versions are available:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Input Extraction Using get()\n// get.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char c, d, t[8], u[8], v;\n\n    c = cin.get();          // extracts a single character\n    cin.get(d);             // extracts a single character\n    cin.get(t, 8);          // newline delimiter - accepts up to 7 chars\n                            //    and adds a null byte\n    cin.ignore(2000, \'\\n\'); // extracts the \'j\' and the newline\n    cin.get(u, 8, \'\\t\');    // tab delimiter - accepts up to 7 chars and\n                            //    adds a null byte\n    cin.ignore();           // extracts the tab\n    cin.get(v);             // extracts a single character\n\n    cout << "c = " << c << endl;\n    cout << "d = " << d << endl;\n    cout << "t = " << t << endl;\n    cout << "u = " << u << endl;\n    cout << "v = " << v << endl;\n}\n')),(0,i.kt)("p",null,"The above program produces the following results for the input shown (the character ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," refers to the horizontal tab character):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Input stream : abcdefghij\n            klmn_opqr\nOutput:\n-------\nc = a\nd = b\nt = cdefghi\nu = klmn\nv = o\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"get()")," does not skip leading whitespace. ",(0,i.kt)("inlineCode",{parentName:"p"},"get(,)")," leaves the delimiting character in the input buffer. In using ",(0,i.kt)("inlineCode",{parentName:"p"},"get(,)")," we need to remove the delimiting character, if there is one. Both string versions - ",(0,i.kt)("inlineCode",{parentName:"p"},"get(char*, int)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"get(char*, int, char)")," - append a null byte to the sequence of characters stored in memory."),(0,i.kt)("h4",{id:"getline"},(0,i.kt)("inlineCode",{parentName:"h4"},"getline()")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"getline()")," behaves like ",(0,i.kt)("inlineCode",{parentName:"p"},"get()"),", but extracts the delimiting character from the input buffer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Input Extraction using getline()\n// getline.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char t[8], u[8], v;\n\n    cin.getline(t, 8);       // newline delimiter - accepts up to 7 chars\n                             //    and adds a null byte\n    cin.getline(u, 8, \'\\t\'); // tab delimiter - accepts up to 7 chars and\n                             //    adds a null byte\n    cin.get(v);              // extracts a single character\n\n    cout << "t = " << t << endl;\n    cout << "u = " << u << endl;\n    cout << "v = " << v << endl;\n}\n')),(0,i.kt)("p",null,"The above program produces the following results for the input shown (the character ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," refers to the horizontal tab character):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Input stream : cdefghi\n            jklmn_opqr\nOutput:\n-------\nt = cdefghi\nu = jklmn\nv = o\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"getline()"),", like ",(0,i.kt)("inlineCode",{parentName:"p"},"get()"),", does not skip leading whitespace and appends a null byte to the sequence of characters stored in system memory."),(0,i.kt)("h2",{id:"output-objects"},"Output Objects"),(0,i.kt)("p",null,"An output object is an instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," class. The ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," class defines the structure of an output device. An ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," object copies data from system memory into an output stream; in copying, it converts the data in system memory into a sequence of characters."),(0,i.kt)("p",null,"The standard ",(0,i.kt)("inlineCode",{parentName:"p"},"iostream")," library defines three distinct standard output objects:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cout"),": Transfers a buffered sequence of characters to the standard output device"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cerr"),": Transfers an unbuffered sequence of characters to the standard error output device"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"clog"),": Transfers a buffered sequence of characters to the standard error output device")),(0,i.kt)("h3",{id:"inserting-data"},"Inserting Data"),(0,i.kt)("p",null,"The expression for inserting data into an output stream takes the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"output << identifier\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"output")," is the name of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," object, ",(0,i.kt)("inlineCode",{parentName:"p"},"<<")," is the insertion operator and ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," is the name of the variable or object that holds the data."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'int i = 6;\nchar c = \' \';\ndouble x = 9.75;\nchar s[] = "Harry";\ncout << i;\ncout << c;\ncout << x;\ncout << c;\ncout << s;\ncout << endl;\ncerr << "Data has been written";\n')),(0,i.kt)("p",null,"Input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"6 9.75 Harry\n")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Data has been written\n")),(0,i.kt)("p",null,"Each expression that takes an ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," object as its left operand converts the data in its right operand into a sequence of characters based on the type of the expression's right operand."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"endl")," inserts a newline character into the output stream and flushes the stream's buffer."),(0,i.kt)("h3",{id:"cascading-1"},"Cascading"),(0,i.kt)("p",null,"We may combine a sequence of insertion operations into a compound insertion expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'int i = 6;\nchar c = \' \';\ndouble x = 9.75;\nchar s[] = "Harry";\n\ncout << i << c << x << c << s << endl;\n\ncerr << "Data has been written";\n')),(0,i.kt)("p",null,"Input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"6 9.75 Harry\n")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Data has been written\n")),(0,i.kt)("h3",{id:"member-functions-1"},"Member Functions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," class supports the following public member functions for formatting control:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"width(int)"),": Sets the field width to the integer received"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fill(char)"),": Sets the padding character to the character received"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"setf(...)"),": Sets a formatting flag to the flag received"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"unsetf(...)"),": Unsets a formatting flag for the flag received"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"precision(int)"),": Sets the decimal precision to the integer received")),(0,i.kt)("h4",{id:"width"},(0,i.kt)("inlineCode",{parentName:"h4"},"width()")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"width(int)")," member function specifies the minimum width of the ",(0,i.kt)("em",{parentName:"p"},"next")," output field:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Field Width\n// width.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int attendance = 27;\n    cout << "1234567890" << endl;\n    cout.width(10);\n    cout << attendance << endl;\n    cout << attendance << endl;\n}\n')),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"1234567890\n        27\n27\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"width(int)")," applies only to the next field. Note how the field width for the first display of ",(0,i.kt)("inlineCode",{parentName:"p"},"attendance")," is 10, while the field width for the second display of ",(0,i.kt)("inlineCode",{parentName:"p"},"attendance")," is just the minimum number of characters needed to display the value (2)."),(0,i.kt)("h4",{id:"fill"},(0,i.kt)("inlineCode",{parentName:"h4"},"fill()")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fill(char)")," member function defines the padding character. The output object inserts this character into the stream wherever text occupies less space than the specified field width. The default fill character is ",(0,i.kt)("inlineCode",{parentName:"p"},"' '")," (space). To pad a field with ",(0,i.kt)("inlineCode",{parentName:"p"},"'*'"),"s, we add:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Padding\n// fill.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int attendance = 27;\n    cout << \"1234567890\" << endl;\n    cout.fill('*');\n    cout.width(10);\n    cout << attendance << endl;\n}\n")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"1234567890\n********27\n")),(0,i.kt)("p",null,"The padding character remains unchanged, until we reset it."),(0,i.kt)("h4",{id:"setf-unsetf---format-control"},(0,i.kt)("inlineCode",{parentName:"h4"},"setf()"),", ",(0,i.kt)("inlineCode",{parentName:"h4"},"unsetf()")," - Format control"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"setf()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"unsetf()")," member functions control formatting and alignment. Their control flags include:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Control Flag"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Result"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ios::fixed")),(0,i.kt)("td",{parentName:"tr",align:"center"},"ddd.ddd")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ios::scientific")),(0,i.kt)("td",{parentName:"tr",align:"center"},"d.ddddddEdd")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ios::left")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Align left")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"ios::right")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Align right")))),(0,i.kt)("p",null,"The scope resolution (",(0,i.kt)("inlineCode",{parentName:"p"},"ios::"),") on these flags identifies them as part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ios")," class."),(0,i.kt)("p",null,"The default format in C++ is ",(0,i.kt)("em",{parentName:"p"},"general format"),", which outputs data in the simplest, most succinct way possible (1.34, 1.345E10, 1.345E-20). To output a fixed number of decimal places, we select ",(0,i.kt)("em",{parentName:"p"},"fixed format"),". To specify fixed format, we pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ios::fixed")," flag to ",(0,i.kt)("inlineCode",{parentName:"p"},"setf()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Fixed Format\n// fixed.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    double pi = 3.141592653;\n    cout << "1234567890" << endl;\n    cout.width(10);\n    cout.setf(ios::fixed);\n    cout << pi << endl;\n}\n')),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"1234567890\n  3.141593\n")),(0,i.kt)("p",null,"Format settings persist until we change them. To unset fixed format, we pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ios::fixed")," flag to the ",(0,i.kt)("inlineCode",{parentName:"p"},"unsetf()")," member function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Unset Fixed Format\n// unsetf.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    double pi = 3.141592653;\n    cout << "1234567890" << endl;\n    cout.width(10);\n    cout.setf(ios::fixed);\n    cout << pi << endl;\n    cout.unsetf(ios::fixed);\n    cout << pi << endl;\n}\n')),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"1234567890\n  3.141593\n3.14159\n")),(0,i.kt)("p",null,"To specify scientific format, we pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ios::scientific")," flag to the ",(0,i.kt)("inlineCode",{parentName:"p"},"setf()")," member function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Scientific Format\n// scientific.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    double pi = 3.141592653;\n    cout << "12345678901234" << endl;\n    cout.width(14);\n    cout.setf(ios::scientific);\n    cout << pi << endl;\n}\n')),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"12345678901234\n  3.141593e+00\n")),(0,i.kt)("p",null,"To turn off scientific format, we pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ios::scientific")," flag to the ",(0,i.kt)("inlineCode",{parentName:"p"},"unsetf()")," member function."),(0,i.kt)("h4",{id:"setf-unsetf---alignment"},(0,i.kt)("inlineCode",{parentName:"h4"},"setf()"),", ",(0,i.kt)("inlineCode",{parentName:"h4"},"unsetf()")," - Alignment"),(0,i.kt)("p",null,"The default alignment is right-justified."),(0,i.kt)("p",null,"To switch to left-justification, we pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ios::left")," flag to the ",(0,i.kt)("inlineCode",{parentName:"p"},"setf()")," member function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Left Justified\n// left.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    double pi = 3.141592653;\n    cout << \"1234567890\" << endl;\n    cout.width(10);\n    cout.fill('?');\n    cout.setf(ios::left);\n    cout << pi << endl;\n}\n")),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"1234567890\n3.14159???\n")),(0,i.kt)("p",null,"To switch off left-justification, we pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ios::left")," flag to the ",(0,i.kt)("inlineCode",{parentName:"p"},"unsetf()")," member function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"cout.unsetf(ios::left);\n")),(0,i.kt)("h4",{id:"precision"},(0,i.kt)("inlineCode",{parentName:"h4"},"precision()")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"precision()")," member function sets the precision of subsequent floating-point fields. The default precision is 6 units. General, fixed, and scientific formats implement precision differently. General format counts the number of significant digits. Scientific and fixed formats count the number of digits following the decimal point."),(0,i.kt)("p",null,"For a precision of 2 under general format, we write"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Precision\n// precison.cpp\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    double pi = 3.141592653;\n    cout << "1234567890" << endl;\n    cout.setf(ios::fixed);\n    cout.width(10);\n    cout.precision(2);\n    cout << pi << endl;\n}\n')),(0,i.kt)("p",null,"Output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"1234567890\n      3.14\n")),(0,i.kt)("p",null,"The precision setting applies to the output of all subsequent floating-point values until we change it."),(0,i.kt)("h2",{id:"manipulators-optional"},"Manipulators (Optional)"),(0,i.kt)("p",null,"The C++ language defines manipulators that are elegant alternatives to member function calls. These manipulators are operands for the extraction and insertion operators. Manipulators that don't take any argument do not include parentheses and are defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"<iostream>"),". Those that take an argument include parentheses and are defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"<iomanip>"),". That is, we must include ",(0,i.kt)("inlineCode",{parentName:"p"},"<iomanip>")," whenever we use manipulators that take an argument."),(0,i.kt)("h3",{id:"input-manipulators"},"Input Manipulators"),(0,i.kt)("p",null,"The manipulators of input objects are listed below:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Manipulator"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Effect"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"skipws")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Skip whitespace")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"noskipws")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Turn off skip whitespace")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"setw(int)")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Set the field width for next input (strings only)")))),(0,i.kt)("p",null,"The argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"setw()")," should be one more than the maximum number of input bytes to be read. Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"setw()")," manipulator is an alternative to ",(0,i.kt)("inlineCode",{parentName:"p"},"get(char*, int)"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"setw()")," skips leading whitespace unless we turn off skipping."),(0,i.kt)("p",null,"Once a manipulator has modified the format settings of an input object, those settings remain modified."),(0,i.kt)("p",null,"We may combine manipulators with input variables directly to form compound expressions. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Input Manipulators\n// manipulator.cpp\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main( ) {\n    char a[5], b[2], c, d[7];\n    cout << "Enter : ";\n    cin >> setw(5) >> a >>\n        setw(2) >> b >> noskipws >>\n        c >> skipws >> d;\n    cout << "Stored \'" << a <<\n            "\' & \'" <<  b <<\n            "\' & \'" << c <<\n            "\' & \'" << d << "\'" << endl;\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Enter :     abcde          fgh\n\nStored 'abcd' & 'e' & ' ' & 'fgh'\n")),(0,i.kt)("h3",{id:"output-manipulators"},"Output Manipulators"),(0,i.kt)("p",null,"The manipulators of output objects are listed below:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Manipulator"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Effect"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"fixed")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Output floating-point numbers in fixed-point format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"scientific")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Output floating-point numbers in scientific format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"left")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Left justify")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"right")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Right justify")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"endl")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Output end of line and flush the buffer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"setprecision(int)")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Set the precision of the output")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"setfill(int)")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Set the fill character for the field width")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"setw(int)")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Set the field width for the next output operand only")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"setbase(int)")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Set the base of the number system for int output")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"flush")),(0,i.kt)("td",{parentName:"tr",align:"center"},"Flush the output buffer")))),(0,i.kt)("p",null,"Manipulators (except for ",(0,i.kt)("inlineCode",{parentName:"p"},"setw(i)"),", which only modifies the format setting for the next object) modify the format settings until we change them."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"cout << fixed << left << setw(5) <<\n       setprecision(1) << 12.376 <<\n       setprecision(5) << 12.376 <<\n       endl;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"12.4 12.37600\n")),(0,i.kt)("h3",{id:"reference-example-optional"},"Reference Example (Optional)"),(0,i.kt)("p",null,"The following program produces the output shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main( ) {\n    /* integers */\n    cout << \"\\n* ints *\\n\"\n    << \"1234567890\\n\"\n    << \"----------\\n\"\n    << 4321 << '\\n'\n    << setw(7) << 4321 << '\\n'\n    << setw(7) << setfill('0') << 4321 << setfill(' ')<<'\\n'\n    << setw(7) << left << 4321 << right << '\\n';\n    /* floats */\n    cout << \"\\n* floats *\\n\"\n    << \"1234567890\\n\"\n    << \"----------\\n\"\n    << 4321.9876546F << '\\n';\n    /* doubles */\n    cout << \"\\n* doubles *\\n\"\n    << \"1234567890\\n\"\n    << \"----------\\n\"\n    << fixed << 4.9876546 << '\\n'\n    << setw(7) << setprecision(3) << 4.9876546 << '\\n'\n    << setw(7) << setfill('0') << 4.9876546 << '\\n'\n    << setw(7) << left << 4.9876546 << right << '\\n';\n    /* characters */\n    cout << \"\\n* chars *\\n\"\n    << \"1234567890\\n\"\n    << \"----------\\n\"\n    << 'd' << '\\n'\n    << int('d') << '\\n';\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"* ints *\n1234567890\n----------\n4321\n4321\n0004321\n4321\n\n* floats *\n1234567890\n----------\n4321.99\n\n* doubles *\n1234567890\n----------\n4.987655\n4.988\n004.988\n4.98800\n\n* chars *\n1234567890\n----------\nd\n100\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"double")," or a ",(0,i.kt)("inlineCode",{parentName:"li"},"float")," rounds to the requested precision"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"char")," data displays in either character or decimal format. To output its numeric code, we cast the value to an ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," (the value output for ",(0,i.kt)("inlineCode",{parentName:"li"},"d")," here is its ASCII value).")),(0,i.kt)("h2",{id:"state"},"State"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ios")," base class defines public member functions that report or change the state of ",(0,i.kt)("inlineCode",{parentName:"p"},"istream")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," objects. These member functions include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"good()"),": The next operation might succeed"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fail()"),": The next operation will fail"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"eof()"),": End of data has been encountered"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bad()"),": The data may be corrupted"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"clear()"),": Reset the state to good")),(0,i.kt)("p",null,"For user-friendly input processing, we should check the state of the input object every time it extracts a sequence of bytes from the input buffer. If the object has encountered an invalid character, the object will fail and leave that invalid character in the input buffer and the ",(0,i.kt)("inlineCode",{parentName:"p"},"fail()")," member function will return true."),(0,i.kt)("p",null,"Before a failed object can continue extracting data from the input buffer, we must clear the object of its failed state. The ",(0,i.kt)("inlineCode",{parentName:"p"},"clear()")," function resets the state of the object to good:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"if(cin.fail()) {            // checks if cin is in a failed state\n    cin.clear();            // clears state to allow further extraction\n    cin.ignore(2000, '\\n'); // clears the input buffer\n}\n")),(0,i.kt)("p",null,"The following section provides a complete example."),(0,i.kt)("h2",{id:"robust-validation"},"Robust Validation"),(0,i.kt)("p",null,"Robust validation enhances the friendliness of any application that processes input. The state functions of the ",(0,i.kt)("inlineCode",{parentName:"p"},"iostream")," classes help us validate input robustly. Robust validation checks the input object's state after each extraction to ensure that the object has converted the sequence of bytes into a value and that that converted value is valid and within admissible bounds. Robust validation rejects invalid input and out-of-bound values, resetting any failed state and requesting fresh input as necessary from the user."),(0,i.kt)("h3",{id:"getposint"},(0,i.kt)("inlineCode",{parentName:"h3"},"getPosInt()")),(0,i.kt)("p",null,"To extract a positive ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," that is not greater than ",(0,i.kt)("inlineCode",{parentName:"p"},"max")," from the standard input device, we write"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// getPosInt extracts a positive integer <= max\n// from standard input and returns its value\n//\nint getPosInt(int max) {\n    int value;\n    int keepreading;\n\n    keepreading = 1;\n    do {\n        cout << "Enter a positive integer (<= " << max << ") : ";\n        cin  >> value;\n\n        if (cin.fail()) {   // check for invalid character\n            cerr << "Invalid character.  Try Again." << endl;\n            cin.clear();\n            cin.ignore(2000, \'\\n\');\n        } else if (value <= 0 || value > max) {\n            cerr << value << " is outside the range [1," <<\n                max << \']\' << endl;\n            cerr << "Invalid input.  Try Again." << endl;\n            cin.ignore(2000, \'\\n\');\n        // you may choose to omit this branch\n        } else if (char(cin.get()) != \'\\n\') {\n            cerr << "Trailing characters.  Try Again." << endl;\n            cin.ignore(2000, \'\\n\');\n        } else\n            keepreading = 0;\n    } while(keepreading == 1);\n\n    return value;\n}\n')),(0,i.kt)("h2",{id:"file-stream-classes-optional"},"File Stream Classes (Optional)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ios")," inheritance hierarchy includes three derived classes specifically designed for processing file streams. These classes manage the communications between file streams containing 8-bit bytes and system memory."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"full ios hierarchy",src:n(9938).Z,width:"384",height:"336"})),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fstream")," system header file defines its classes in the std namespace:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <fstream>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fstream")," classes include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ifstream"),": Processes input from a file stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ofstream"),": Processes output to a file stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fstream"),": Processes input from and output to a file stream")),(0,i.kt)("p",null,"These classes access a file stream through separate input and output buffers."),(0,i.kt)("h3",{id:"extraction-and-insertion-operator-overloads"},"Extraction and Insertion Operator Overloads"),(0,i.kt)("p",null,"The standard library overloads the extraction and insertion operators for the fundamental types. We overload these operators for ",(0,i.kt)("inlineCode",{parentName:"p"},"fstream")," objects as left operands and custom types as right operands."),(0,i.kt)("h4",{id:"fundamental-types"},"Fundamental Types"),(0,i.kt)("p",null,"For fundamental types see the chapter entitled ",(0,i.kt)("a",{parentName:"p",href:"/C-Encapsulation/input-and-output-operators"},"Input and Output Operators"),"."),(0,i.kt)("h4",{id:"custom-types"},"Custom Types"),(0,i.kt)("p",null,"Typically, custom types require separate overloads of both extraction and insertion operators."),(0,i.kt)("p",null,"While reading standard input involves prompting the suer, reading a file does not require any prompts. The extraction operator for file input objects excludes prompts. Since writing to a file matches the convention for subsequent reading from that file, the output to a file generally differs from the more decorated output to be read by the user. Moreover, since the insertion operator that takes an ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," object as its left operand class is a templated function and the ",(0,i.kt)("inlineCode",{parentName:"p"},"ofstream")," class is a class derived from the ",(0,i.kt)("inlineCode",{parentName:"p"},"ostream")," class, ambiguities arise with direct overloading of the operator for a custom type. One way to avoid these ambiguities is to define a separate file class for the custom type and overload the insertion operator for that file class."),(0,i.kt)("p",null,"The file related additions are highlighted in the listings below."),(0,i.kt)("p",null,"The header file for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," class includes the definition of a ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentFile")," class that overloads the insertion operators for an ",(0,i.kt)("inlineCode",{parentName:"p"},"ofstream")," object that receives the ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Student.h\n\n#include <iostream> // for std::ostream, std::istream\n#include <fstream>  // for std::ifstream\nconst int NG = 13;\n\nclass StudentFile;\n\nclass Student {\n    int no;\n    float grade[NG];\n    int ng;\npublic:\n    Student();\n    Student(int);\n    Student(int, const float*, int);\n    void read(std::istream&);\n    void read(std::ifstream&);\n    void display(std::ostream& os) const;\n    void display(StudentFile& os) const;\n};\n\nstd::istream& operator>>(std::istream& is, Student& s);\nstd::ostream& operator<<(std::ostream& os, const Student& s);\nstd::ifstream& operator>>(std::ifstream& is, Student& s);\n\nclass StudentFile {\npublic:\n    std::ofstream f;\n    StudentFile(const char*);\n    StudentFile& operator<<(char);\n    StudentFile& operator<<(int);\n    StudentFile& operator<<(float);\n    void close();\n};\n\nStudentFile& operator<<(StudentFile& os, const Student& s);\n")),(0,i.kt)("p",null,"The implementation file overloads the file extraction and insertion operators for our ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," class and defines the insertion operator for ",(0,i.kt)("inlineCode",{parentName:"p"},"StudentFile")," objects as left operands and fundamental types as right operands:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Student.cpp\n\n#include "Student.h"\n\nStudent::Student() {\n    no = 0;\n    ng = 0;\n}\n\nStudent::Student(int n) {\n    *this = Student(n, nullptr, 0);\n}\n\nStudent::Student(int sn, const float* g, int ng_) {\n    bool valid = sn > 0 && g != nullptr && ng_ >= 0;\n    if (valid)\n        for (int i = 0; i < ng_ && valid; i++)\n            valid = g[i] >= 0.0f && g[i] <= 100.0f;\n\n    if (valid) {\n        // accept the client\'s data\n        no = sn;\n        ng = ng_ < NG ? ng_ : NG;\n        for (int i = 0; i < ng; i++)\n            grade[i] = g[i];\n    } else {\n        *this = Student();\n    }\n}\n\nvoid Student::read(std::istream& is) {\n    int no;          // will hold the student number\n    int ng;          // will hold the number of grades\n    float grade[NG]; // will hold the grades\n\n    std::cout << "Student Number : ";\n    is >> no;\n    std::cout << "Number of Grades : ";\n    is >> ng;\n    if (ng > NG) ng = NG;\n    for (int i = 0; i < ng; i++) {\n        std::cout << "Grade " << i + 1 << " : ";\n        is >> grade[i];\n    }\n\n    // construct a temporary Student\n    Student temp(no, grade, ng);\n    // if data is valid, copy temporary object into current object\n    if (temp.no != 0)\n        *this = temp;\n}\n\nvoid Student::read(std::ifstream& is) {\n    int no;          // will hold the student number\n    int ng;          // will hold the number of grades\n    float grade[NG]; // will hold the grades\n\n    is >> no;\n    is >> ng;\n    if (ng > NG) ng = NG;\n    for (int i = 0; i < ng; i++) {\n        is >> grade[i];\n    }\n\n    // construct a temporary Student\n    Student temp(no, grade, ng);\n    // if data is valid, copy temporary object into current object\n    if (temp.no != 0)\n        *this = temp;\n}\n\nvoid Student::display(std::ostream& os) const {\n    if (no > 0) {\n        os << no << ":\\n";\n        os.setf(std::ios::fixed);\n        os.precision(2);\n        for (int i = 0; i < ng; i++) {\n            os.width(6);\n            os << grade[i] << std::endl;\n        }\n        os.unsetf(std::ios::fixed);\n        os.precision(6);\n    } else {\n        os << "no data available" << std::endl;\n    }\n}\n\nvoid Student::display(StudentFile& os) const {\n    os << no << \'\\n\';\n    os << ng << \'\\n\';\n    for (int i = 0; i < ng; i++)\n        os << grade[i] << \'\\n\';\n}\n\nstd::ostream& operator<<(std::ostream& os, const Student& s) {\n    s.display(os);\n    return os;\n}\n\nstd::istream& operator>>(std::istream& is, Student& s) {\n    s.read(is);\n    return is;\n}\n\nstd::ifstream& operator>>(std::ifstream& is, Student& s) {\n    s.read(is);\n    return is;\n}\n\nStudentFile& operator<<(StudentFile& f, const Student& s) {\n    s.display(f);\n    return f;\n}\n\nStudentFile::StudentFile(const char* filename) : f(filename) {}\n\nStudentFile& StudentFile::operator<<(char c) {\n    f << c;\n    return *this;\n}\n\nStudentFile& StudentFile::operator<<(int i) {\n    f << i;\n    return *this;\n}\n\nStudentFile& StudentFile::operator<<(float v) {\n    f << v;\n    return *this;\n}\n\nvoid StudentFile::close() {\n    f.close();\n}\n')),(0,i.kt)("p",null,"Note the definitions of the ",(0,i.kt)("inlineCode",{parentName:"p"},"read()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"display()")," member functions overloaded for file input and output respectively."),(0,i.kt)("p",null,"The client file that uses this upgraded ",(0,i.kt)("inlineCode",{parentName:"p"},"Student")," class creates the file objects, writes to them and reads from them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Custom File Operators\n// customFile.cpp\n\n#include <iostream>\n#include "Student.h"\n\nint main ( ) {\n    Student harry;\n\n    std::cin >> harry;\n    std::cout << harry;\n\n    StudentFile studentFile("Student.txt");\n    studentFile << harry;\n    studentFile.close();\n\n    std::ifstream inFile("Student.txt");\n    inFile >> harry;\n    std::cout << harry;\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"Student Number : 1234\nNumber of Grades : 3\nGrade 1 : 56.7\nGrade 2 : 78.9\nGrade 3 : 85.4\n1234:\n 56.70\n 78.90\n 85.40\n1234:\n 56.70\n 78.90\n 85.40\n")),(0,i.kt)("p",null,"The records written to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Student.txt")," file by this program are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"1234\n 3\n56.7\n78.9\n85.4\n")),(0,i.kt)("h3",{id:"nice-to-know-optional"},"Nice to Know (Optional)"),(0,i.kt)("h4",{id:"open-mode-flags"},"Open-Mode Flags"),(0,i.kt)("p",null,"To customize a file object's connection mode we use combinations of flags passed as an optional second argument to the object's constructor or its ",(0,i.kt)("inlineCode",{parentName:"p"},"open()")," member function."),(0,i.kt)("p",null,"The flags defining the connection mode are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::in"),": Open for reading"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::out"),": Open for writing"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::app"),": Open for appending"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::trunc"),": Open for writing, but truncate if file exists"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::ate"),": Move to the end of the file once the file is opened")),(0,i.kt)("p",null,"Practical combinations of these flags include"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::in|std::ios::out"),": Open for reading and writing (default)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::in|std::ios::out|std::ios::trunc"),": Open for reading and overwriting"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::in|std::ios::out|std::ios::app"),": Open for reading and appending"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::out|std::ios::trunc"),": Open for overwriting")),(0,i.kt)("p",null,"The vertical bar (",(0,i.kt)("inlineCode",{parentName:"p"},"|"),") is the bit-wise or operator."),(0,i.kt)("h4",{id:"the-defaults"},"The Defaults"),(0,i.kt)("p",null,"The default combinations for no-argument and one-argument constructors are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ifstream"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::in")," - Open for reading"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ofstream"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::out")," - Open for writing"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fstream"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"std::ios::in|std::ios::out")," - Open for reading and writing")),(0,i.kt)("h4",{id:"the-logical-negation-operator"},"The Logical Negation Operator"),(0,i.kt)("p",null,"The standard library overloads the logical negation operator (!) as an alternative to the ",(0,i.kt)("inlineCode",{parentName:"p"},"fail()")," query. This operator reports ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the latest operation has failed or if the stream has encountered a serious error."),(0,i.kt)("p",null,"We can invoke this operator on any stream object to check the success of the most recent activity:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'if (fin.fail()) {\n    std::cerr << "Read error";\n    fin.clear();\n}\n')),(0,i.kt)("p",null,"becomes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'if (!fin) {\n    std::cerr << "Read error";\n    fin.clear();\n}\n')),(0,i.kt)("p",null,"The operator applied directly to a file object returns the state of the connection:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <fstream>\n\nint main() {\n    std::ofstream fout("output.txt");  // connects fout to output.txt\n                                       // for writing\n    if (!fout) {\n        std::cerr << "File is not open" << std::endl;\n    } else {\n        std::cout << "File is open" << std::endl;\n    }\n}\n')),(0,i.kt)("h4",{id:"rewinding-a-connection"},"Rewinding a Connection"),(0,i.kt)("h5",{id:"istream-fstream"},"istream, fstream"),(0,i.kt)("p",null,"To rewind an input stream we call:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"istream& seekg(0)"),": Sets the current position in the input stream to ",(0,i.kt)("inlineCode",{parentName:"li"},"0"))),(0,i.kt)("h5",{id:"ostream-fstream"},"ostream, fstream"),(0,i.kt)("p",null,"To rewind an output stream we call:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ostream& seekp(0)"),": Sets the current position in the output stream to ",(0,i.kt)("inlineCode",{parentName:"li"},"0"))),(0,i.kt)("h4",{id:"premature-closing"},"Premature Closing"),(0,i.kt)("p",null,"To close a file connection before the file object has gone out of scope, we call the ",(0,i.kt)("inlineCode",{parentName:"p"},"close()")," member function on the object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Concatenate Two Files\n// concatenate.cpp\n\n#include <fstream>\n\nint main() {\n    std::ifstream in("src1.txt");    // open 1st source file\n    std::ofstream out("output.txt"); // open destination file\n\n    if (in) {\n        while (!in.eof())\n            out << in.get();        // byte by byte copy\n        in.clear();\n        in.close();                 // close 1st source file\n    }\n\n    in.open("src2.txt");            // open 2nd source file\n\n    if (in) {\n        while (!in.eof())\n            out << in.get();        // byte by byte copy\n        in.clear();\n    }\n}\n')),(0,i.kt)("h4",{id:"writing-to-and-reading-from-the-same-file"},"Writing to and Reading from the Same File"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fstream")," class supports both reading and writing operations. An instance of this class can write to a file and read from that same file."),(0,i.kt)("p",null,"For example, the following program produces the output shown below"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// File Objects - writing and reading\n// fstream.cpp\n\n#include <iostream>\n#include <fstream>\n\nint main() {\n\n    std::fstream f("file.txt",\n    std::ios::in|std::ios::out|std::ios::trunc);\n    f << "Line 1" << std::endl;   // record 1\n    f << "Line 2" << std::endl;   // record 2\n    f << "Line 3" << std::endl;   // record 3\n    f.seekp(0);                   // rewind output\n    f << "****";                  // overwrite\n\n    char c;\n    f.seekg(0);                   // rewind input\n    f << std::noskipws;           // don\'t skip whitespace\n    while (f.good()) {\n        f >> c;                   // read 1 char at a time\n        if (f.good())\n            std::cout << c;       // display the character\n    }\n    f.clear();                    // clear failed (eof) state\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},"**** 1\nLine 2\nLine 3\n")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The extraction and insertion operators support cascading"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get()")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"getline()")," read strings with whitespace"),(0,i.kt)("li",{parentName:"ul"},"A field width setting only holds for the next field"),(0,i.kt)("li",{parentName:"ul"},"All non-field width settings persist until changed"),(0,i.kt)("li",{parentName:"ul"},"Precision has different meanings under general, scientific, and fixed formats"),(0,i.kt)("li",{parentName:"ul"},"Manipulators are the elegant alternative to member function based format settings"),(0,i.kt)("li",{parentName:"ul"},"Manipulators that take arguments are defined in ",(0,i.kt)("inlineCode",{parentName:"li"},"#include <iomanip>")),(0,i.kt)("li",{parentName:"ul"},"A failed state must be cleared before processing can continue"),(0,i.kt)("li",{parentName:"ul"},"The extraction and insertion operators are overloaded for file objects as left operands and fundamental types as right operands"),(0,i.kt)("li",{parentName:"ul"},"An input file object is an instance of an ",(0,i.kt)("inlineCode",{parentName:"li"},"ifstream")," class"),(0,i.kt)("li",{parentName:"ul"},"An output file object is an instance of an ",(0,i.kt)("inlineCode",{parentName:"li"},"ofstream")," class"),(0,i.kt)("li",{parentName:"ul"},"We may overload the extraction and insertion operators for file objects as left operands and our class types as right operands")),(0,i.kt)("h2",{id:"exercises"},"Exercises"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Experiment with ",(0,i.kt)("inlineCode",{parentName:"li"},"get()"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"getline()")," and state on little programs of your own")))}c.isMDXComponent=!0},9938:function(e,t,n){t.Z=n.p+"assets/images/full_ios_hierarchy-96fbcec3426501ebbc8ce43c3f4aab90.png"},6735:function(e,t,n){t.Z=n.p+"assets/images/memory_io-8ad76340e799a726988f28d79ff08d64.png"},2824:function(e,t){t.Z="data:image/png;base64,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"}}]);